{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-filter",
  "type": "registry:block",
  "title": "Data table filter",
  "author": "Kian Bazarjani <kian@bazza.dev>",
  "description": "A powerful data table filter component inspired by Linear.",
  "dependencies": [
    "@tanstack/match-sorter-utils@8.19.4",
    "@tanstack/react-table@8.21.2",
    "date-fns@4.1.0"
  ],
  "registryDependencies": [
    "button",
    "calendar",
    "checkbox",
    "command",
    "dropdown-menu",
    "input",
    "label",
    "popover",
    "separator",
    "slider",
    "table",
    "tabs",
    "tooltip"
  ],
  "files": [
    {
      "path": "registry/data-table-filter/components/data-table-filter.tsx",
      "content": "'use client'\n\nimport { PropertyFilterList } from '@/registry/data-table-filter/components/property-filter-list'\nimport { TableFilterActions } from '@/registry/data-table-filter/components/table-filter-actions'\nimport { TableFilter } from '@/registry/data-table-filter/components/table-filter-menu'\nimport type { Table } from '@tanstack/react-table'\n\nexport function DataTableFilter<TData, TValue>({\n  table,\n}: { table: Table<TData> }) {\n  return (\n    <div className=\"flex w-full items-start justify-between gap-2\">\n      <div className=\"flex h-full w-full items-stretch gap-2\">\n        <TableFilter table={table} />\n        <PropertyFilterList table={table} />\n      </div>\n      <TableFilterActions table={table} />\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/components/debounced-input.tsx",
      "content": "'use client'\n\nimport { Input } from '@/components/ui/input'\nimport { useEffect, useState } from 'react'\n\nexport function DebouncedInput({\n  value: initialValue,\n  onChange,\n  debounce = 500,\n  ...props\n}: {\n  value: string | number\n  onChange: (value: string | number) => void\n  debounce?: number\n} & Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange'>) {\n  const [value, setValue] = useState(initialValue)\n\n  useEffect(() => {\n    setValue(initialValue)\n  }, [initialValue])\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      onChange(value)\n    }, debounce)\n\n    return () => clearTimeout(timeout)\n  }, [value, onChange, debounce])\n\n  return (\n    <Input\n      {...props}\n      value={value}\n      onChange={(e) => setValue(e.target.value)}\n    />\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/components/property-filter-list.tsx",
      "content": "'use client'\n\nimport { Button } from '@/components/ui/button'\nimport { Separator } from '@/components/ui/separator'\nimport { PropertyFilterOperatorController } from '@/registry/data-table-filter/components/property-filter-operator'\nimport { PropertyFilterSubject } from '@/registry/data-table-filter/components/property-filter-subject'\nimport { PropertyFilterValueController } from '@/registry/data-table-filter/components/property-filter-value'\nimport type {\n  ColumnDataType,\n  FilterValue,\n} from '@/registry/data-table-filter/lib/filters'\nimport type { Column, ColumnMeta, Table } from '@tanstack/react-table'\nimport { X } from 'lucide-react'\nimport { getColumn, getColumnMeta } from '../lib/table'\n\nexport function PropertyFilterList<TData>({ table }: { table: Table<TData> }) {\n  const filters = table.getState().columnFilters\n\n  return (\n    <div className=\"flex flex-wrap items-center gap-2 text-xs\">\n      {filters.map((filter) => {\n        const { id } = filter\n\n        const column = getColumn(table, id)\n        const meta = getColumnMeta(table, id)\n\n        // Skip if no filter value\n        if (!filter.value) return null\n\n        // Narrow the type based on meta.type and cast filter accordingly\n        switch (meta.type) {\n          case 'text':\n            return renderFilter<TData, 'text'>(\n              filter as { id: string; value: FilterValue<'text', TData> },\n              column,\n              meta as ColumnMeta<TData, unknown> & { type: 'text' },\n              table,\n            )\n          case 'number':\n            return renderFilter<TData, 'number'>(\n              filter as { id: string; value: FilterValue<'number', TData> },\n              column,\n              meta as ColumnMeta<TData, unknown> & { type: 'number' },\n              table,\n            )\n          case 'date':\n            return renderFilter<TData, 'date'>(\n              filter as { id: string; value: FilterValue<'date', TData> },\n              column,\n              meta as ColumnMeta<TData, unknown> & { type: 'date' },\n              table,\n            )\n          case 'option':\n            return renderFilter<TData, 'option'>(\n              filter as { id: string; value: FilterValue<'option', TData> },\n              column,\n              meta as ColumnMeta<TData, unknown> & { type: 'option' },\n              table,\n            )\n          case 'multiOption':\n            return renderFilter<TData, 'multiOption'>(\n              filter as {\n                id: string\n                value: FilterValue<'multiOption', TData>\n              },\n              column,\n              meta as ColumnMeta<TData, unknown> & {\n                type: 'multiOption'\n              },\n              table,\n            )\n          default:\n            return null // Handle unknown types gracefully\n        }\n      })}\n    </div>\n  )\n}\n\n// Generic render function for a filter with type-safe value\nfunction renderFilter<TData, T extends ColumnDataType>(\n  filter: { id: string; value: FilterValue<T, TData> },\n  column: Column<TData, unknown>,\n  meta: ColumnMeta<TData, unknown> & { type: T },\n  table: Table<TData>,\n) {\n  const { value } = filter\n\n  return (\n    <div\n      key={`filter-${filter.id}`}\n      className=\"flex h-7 items-center rounded-2xl border border-border bg-background shadow-xs\"\n    >\n      <PropertyFilterSubject meta={meta} />\n      <Separator orientation=\"vertical\" />\n      <PropertyFilterOperatorController\n        column={column}\n        columnMeta={meta}\n        filter={value} // Typed as FilterValue<T>\n      />\n      <Separator orientation=\"vertical\" />\n      <PropertyFilterValueController\n        id={filter.id}\n        column={column}\n        columnMeta={meta}\n        table={table}\n      />\n      <Separator orientation=\"vertical\" />\n      <Button\n        variant=\"ghost\"\n        className=\"rounded-none rounded-r-2xl text-xs w-7 h-full\"\n        onClick={() => table.getColumn(filter.id)?.setFilterValue(undefined)}\n      >\n        <X className=\"size-4 -translate-x-0.5\" />\n      </Button>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/components/property-filter-operator.tsx",
      "content": "import { Button } from '@/components/ui/button'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport type { ColumnDataType } from '@/registry/data-table-filter/lib/filters'\nimport {\n  type FilterValue,\n  createNumberRange,\n  dateFilterDetails,\n  filterTypeOperatorDetails,\n  multiOptionFilterDetails,\n  numberFilterDetails,\n  optionFilterDetails,\n  textFilterDetails,\n} from '@/registry/data-table-filter/lib/filters'\nimport type { Column, ColumnMeta, Table } from '@tanstack/react-table'\nimport { useState } from 'react'\n\n// Renders the filter operator display and menu for a given column filter\n// The filter operator display is the label and icon for the filter operator\n// The filter operator menu is the dropdown menu for the filter operator\nexport function PropertyFilterOperatorController<\n  TData,\n  T extends ColumnDataType,\n>({\n  column,\n  columnMeta,\n  filter,\n}: {\n  column: Column<TData, unknown>\n  columnMeta: ColumnMeta<TData, unknown>\n  filter: FilterValue<T, TData>\n}) {\n  const [open, setOpen] = useState<boolean>(false)\n\n  const close = () => setOpen(false)\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"ghost\"\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\n        >\n          <PropertyFilterOperatorDisplay\n            filter={filter}\n            filterType={columnMeta.type}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        <Command loop>\n          <CommandInput placeholder=\"Search...\" />\n          <CommandEmpty>No results.</CommandEmpty>\n          <CommandList className=\"max-h-fit\">\n            <PropertyFilterOperatorMenu\n              column={column}\n              closeController={close}\n            />\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n\nexport function PropertyFilterOperatorDisplay<TData, T extends ColumnDataType>({\n  filter,\n  filterType,\n}: {\n  filter: FilterValue<T, TData>\n  filterType: T\n}) {\n  const details = filterTypeOperatorDetails[filterType][filter.operator]\n\n  return <span>{details.label}</span>\n}\n\ninterface PropertyFilterOperatorMenuProps<TData> {\n  column: Column<TData, unknown>\n  closeController: () => void\n}\n\nexport function PropertyFilterOperatorMenu<TData>({\n  column,\n  closeController,\n}: PropertyFilterOperatorMenuProps<TData>) {\n  const { type } = column.columnDef.meta!\n\n  switch (type) {\n    case 'option':\n      return (\n        <PropertyFilterOptionOperatorMenu\n          column={column}\n          closeController={closeController}\n        />\n      )\n    case 'multiOption':\n      return (\n        <PropertyFilterMultiOptionOperatorMenu\n          column={column}\n          closeController={closeController}\n        />\n      )\n    case 'date':\n      return (\n        <PropertyFilterDateOperatorMenu\n          column={column}\n          closeController={closeController}\n        />\n      )\n    case 'text':\n      return (\n        <PropertyFilterTextOperatorMenu\n          column={column}\n          closeController={closeController}\n        />\n      )\n    case 'number':\n      return (\n        <PropertyFilterNumberOperatorMenu\n          column={column}\n          closeController={closeController}\n        />\n      )\n    default:\n      return null\n  }\n}\n\nfunction PropertyFilterOptionOperatorMenu<TData>({\n  column,\n  closeController,\n}: PropertyFilterOperatorMenuProps<TData>) {\n  const filter = column.getFilterValue() as FilterValue<'option', TData>\n  const filterDetails = optionFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(optionFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    column.setFilterValue((old: typeof filter) => ({ ...old, operator: value }))\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading=\"Operators\">\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {r.value}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction PropertyFilterMultiOptionOperatorMenu<TData>({\n  column,\n  closeController,\n}: PropertyFilterOperatorMenuProps<TData>) {\n  const filter = column.getFilterValue() as FilterValue<'multiOption', TData>\n  const filterDetails = multiOptionFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(multiOptionFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    column.setFilterValue((old: typeof filter) => ({ ...old, operator: value }))\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading=\"Operators\">\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {r.value}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction PropertyFilterDateOperatorMenu<TData>({\n  column,\n  closeController,\n}: PropertyFilterOperatorMenuProps<TData>) {\n  const filter = column.getFilterValue() as FilterValue<'date', TData>\n  const filterDetails = dateFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(dateFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    column.setFilterValue((old: typeof filter) => ({ ...old, operator: value }))\n    closeController()\n  }\n\n  return (\n    <CommandGroup>\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {r.value}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nexport function PropertyFilterTextOperatorMenu<TData>({\n  column,\n  closeController,\n}: PropertyFilterOperatorMenuProps<TData>) {\n  const filter = column.getFilterValue() as FilterValue<'text', TData>\n  const filterDetails = textFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(textFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    column.setFilterValue((old: typeof filter) => ({ ...old, operator: value }))\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading=\"Operators\">\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {r.value}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction PropertyFilterNumberOperatorMenu<TData>({\n  column,\n  closeController,\n}: PropertyFilterOperatorMenuProps<TData>) {\n  const filter = column.getFilterValue() as FilterValue<'number', TData>\n\n  // Show all related operators\n  const relatedFilters = Object.values(numberFilterDetails)\n  const relatedFilterOperators = relatedFilters.map((r) => r.value)\n\n  const changeOperator = (value: (typeof relatedFilterOperators)[number]) => {\n    column.setFilterValue((old: typeof filter) => {\n      // Clear out the second value when switching to single-input operators\n      const target = numberFilterDetails[value].target\n\n      const newValues =\n        target === 'single' ? [old.values[0]] : createNumberRange(old.values)\n\n      return { ...old, operator: value, values: newValues }\n    })\n    closeController()\n  }\n\n  return (\n    <div>\n      <CommandGroup heading=\"Operators\">\n        {relatedFilters.map((r) => (\n          <CommandItem\n            onSelect={() => changeOperator(r.value)}\n            value={r.value}\n            key={r.value}\n          >\n            {r.value} {/**/}\n          </CommandItem>\n        ))}\n      </CommandGroup>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/components/property-filter-subject.tsx",
      "content": "import type { ColumnMeta } from '@tanstack/react-table'\n\nexport function PropertyFilterSubject<TData>({\n  meta,\n}: {\n  meta: ColumnMeta<TData, string>\n}) {\n  const hasIcon = !!meta?.icon\n  return (\n    <span className=\"flex select-none items-center gap-1 whitespace-nowrap px-2 font-medium\">\n      {hasIcon && <meta.icon className=\"size-4 stroke-[2.25px]\" />}\n      <span>{meta.displayName}</span>\n    </span>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/components/property-filter-value.tsx",
      "content": "'use client'\n\nimport { Button } from '@/components/ui/button'\nimport { Calendar } from '@/components/ui/calendar'\nimport { Checkbox } from '@/components/ui/checkbox'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport { Input } from '@/components/ui/input'\nimport {\n  Popover,\n  PopoverAnchor,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport { Slider } from '@/components/ui/slider'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'\nimport { cn } from '@/lib/utils'\nimport { DebouncedInput } from '@/registry/data-table-filter/components/debounced-input'\nimport { flatten, take, uniq } from '@/registry/data-table-filter/lib/array'\nimport type {\n  ColumnOption,\n  ElementType,\n} from '@/registry/data-table-filter/lib/filters'\nimport {\n  type FilterValue,\n  determineNewOperator,\n  numberFilterDetails,\n} from '@/registry/data-table-filter/lib/filters'\nimport type {\n  Column,\n  ColumnMeta,\n  Row,\n  RowData,\n  Table,\n} from '@tanstack/react-table'\nimport { format, isEqual } from 'date-fns'\nimport { Ellipsis } from 'lucide-react'\nimport { cloneElement, isValidElement, useState } from 'react'\nimport type { DateRange } from 'react-day-picker'\n\nexport function PropertyFilterValueController<TData, TValue>({\n  id,\n  column,\n  columnMeta,\n  table,\n}: {\n  id: string\n  column: Column<TData>\n  columnMeta: ColumnMeta<TData, TValue>\n  table: Table<TData>\n}) {\n  return (\n    <Popover>\n      <PopoverAnchor className=\"h-full\" />\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"ghost\"\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\n        >\n          <PropertyFilterValueDisplay\n            id={id}\n            column={column}\n            columnMeta={columnMeta}\n            table={table}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        side=\"bottom\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        <PropertyFilterValueMenu\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      </PopoverContent>\n    </Popover>\n  )\n}\n\ninterface PropertyFilterValueDisplayProps<TData, TValue> {\n  id: string\n  column: Column<TData>\n  columnMeta: ColumnMeta<TData, TValue>\n  table: Table<TData>\n}\n\nexport function PropertyFilterValueDisplay<TData, TValue>({\n  id,\n  column,\n  columnMeta,\n  table,\n}: PropertyFilterValueDisplayProps<TData, TValue>) {\n  switch (columnMeta.type) {\n    case 'option':\n      return (\n        <PropertyFilterOptionValueDisplay\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    case 'multiOption':\n      return (\n        <PropertyFilterMultiOptionValueDisplay\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    case 'date':\n      return (\n        <PropertyFilterDateValueDisplay\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    case 'text':\n      return (\n        <PropertyFilterTextValueDisplay\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    case 'number':\n      return (\n        <PropertyFilterNumberValueDisplay\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    default:\n      return null\n  }\n}\n\nexport function PropertyFilterOptionValueDisplay<TData, TValue>({\n  id,\n  column,\n  columnMeta,\n  table,\n}: PropertyFilterValueDisplayProps<TData, TValue>) {\n  let options: ColumnOption[]\n  const columnVals = table\n    .getCoreRowModel()\n    .rows.flatMap((r) => r.getValue<TValue>(id))\n    .filter((v): v is NonNullable<TValue> => v !== undefined && v !== null)\n\n  // If static options are provided, use them\n  if (columnMeta.options) {\n    options = columnMeta.options\n  }\n\n  // No static options provided,\n  // We should dynamically generate them based on the column data\n  else if (columnMeta.transformOptionFn) {\n    const transformOptionFn = columnMeta.transformOptionFn\n\n    const unique = uniq(columnVals)\n\n    options = unique.map((v) =>\n      transformOptionFn(v as ElementType<NonNullable<TValue>>),\n    )\n  }\n\n  // No static options provided\n  // Missing transformOptionFn - throw error\n  else {\n    throw new Error(\n      'No options provided - this is required for multiOption data type without static options',\n    )\n  }\n\n  const filter = column.getFilterValue() as FilterValue<'option', TData>\n  const selected = options.filter((o) => filter?.values.includes(o.value))\n\n  // We display the selected options based on how many are selected\n  //\n  // If there is only one option selected, we display its icon and label\n  //\n  // If there are multiple options selected, we display:\n  // 1) up to 3 icons of the selected options\n  // 2) the number of selected options\n  if (selected.length === 1) {\n    const { label, icon: Icon } = selected[0]\n    const hasIcon = !!Icon\n    return (\n      <span className=\"inline-flex items-center gap-1\">\n        {hasIcon &&\n          (isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon className=\"size-4 text-primary\" />\n          ))}\n        <span>{label}</span>\n      </span>\n    )\n  }\n  const name = columnMeta.displayName.toLowerCase()\n  const pluralName = name.endsWith('s') ? `${name}es` : `${name}s`\n\n  const hasOptionIcons = !!columnMeta.options\n\n  return (\n    <div className=\"inline-flex items-center gap-0.5\">\n      {hasOptionIcons &&\n        take(selected, 3).map(({ value, icon }) => {\n          const Icon = icon!\n          return isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon key={value} className=\"size-4\" />\n          )\n        })}\n      <span className={cn(hasOptionIcons && 'ml-1.5')}>\n        {selected.length} {pluralName}\n      </span>\n    </div>\n  )\n}\n\nexport function PropertyFilterMultiOptionValueDisplay<TData, TValue>({\n  id,\n  column,\n  columnMeta,\n  table,\n}: PropertyFilterValueDisplayProps<TData, TValue>) {\n  let options: ColumnOption[]\n  const columnVals = table\n    .getCoreRowModel()\n    .rows.flatMap((r) => r.getValue<TValue>(id))\n    .filter((v): v is NonNullable<TValue> => v !== undefined && v !== null)\n\n  // If static options are provided, use them\n  if (columnMeta.options) {\n    options = columnMeta.options\n  }\n\n  // No static options provided,\n  // We should dynamically generate them based on the column data\n  else if (columnMeta.transformOptionFn) {\n    const transformOptionFn = columnMeta.transformOptionFn\n\n    const unique = uniq(columnVals)\n\n    options = unique.map((v) =>\n      transformOptionFn(v as ElementType<NonNullable<TValue>>),\n    )\n  }\n\n  // No static options provided\n  // Missing transformOptionFn - throw error\n  else {\n    throw new Error(\n      'No options provided - this is required for multiOption data type without static options',\n    )\n  }\n\n  const filter = column.getFilterValue() as FilterValue<'multiOption', TData>\n  const selected = options.filter((o) => filter?.values[0].includes(o.value))\n\n  if (selected.length === 1) {\n    const { label, icon: Icon } = selected[0]\n    const hasIcon = !!Icon\n    return (\n      <span className=\"inline-flex items-center gap-1.5\">\n        {hasIcon &&\n          (isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon className=\"size-4 text-primary\" />\n          ))}\n\n        <span>{label}</span>\n      </span>\n    )\n  }\n\n  const name = columnMeta.displayName.toLowerCase()\n\n  const hasOptionIcons = !columnMeta.options?.some((o) => !o.icon)\n\n  return (\n    <div className=\"inline-flex items-center gap-1.5\">\n      {hasOptionIcons && (\n        <div key=\"icons\" className=\"inline-flex items-center gap-0.5\">\n          {take(selected, 3).map(({ value, icon }) => {\n            const Icon = icon!\n            return isValidElement(Icon) ? (\n              cloneElement(Icon, { key: value })\n            ) : (\n              <Icon key={value} className=\"size-4\" />\n            )\n          })}\n        </div>\n      )}\n      <span>\n        {selected.length} {name}\n      </span>\n    </div>\n  )\n}\n\nfunction formatDateRange(start: Date, end: Date) {\n  const sameMonth = start.getMonth() === end.getMonth()\n  const sameYear = start.getFullYear() === end.getFullYear()\n\n  if (sameMonth && sameYear) {\n    return `${format(start, 'MMM d')} - ${format(end, 'd, yyyy')}`\n  }\n\n  if (sameYear) {\n    return `${format(start, 'MMM d')} - ${format(end, 'MMM d, yyyy')}`\n  }\n\n  return `${format(start, 'MMM d, yyyy')} - ${format(end, 'MMM d, yyyy')}`\n}\n\nexport function PropertyFilterDateValueDisplay<TData, TValue>({\n  column,\n}: PropertyFilterValueDisplayProps<TData, TValue>) {\n  const filter = column.getFilterValue()\n    ? (column.getFilterValue() as FilterValue<'date', TData>)\n    : undefined\n\n  if (!filter) return null\n  if (filter.values.length === 0) return <Ellipsis className=\"size-4\" />\n  if (filter.values.length === 1) {\n    const value = filter.values[0]\n\n    const formattedDateStr = format(value, 'MMM d, yyyy')\n\n    return <span>{formattedDateStr}</span>\n  }\n\n  const formattedRangeStr = formatDateRange(filter.values[0], filter.values[1])\n\n  return <span>{formattedRangeStr}</span>\n}\n\nexport function PropertyFilterTextValueDisplay<TData, TValue>({\n  column,\n}: PropertyFilterValueDisplayProps<TData, TValue>) {\n  const filter = column.getFilterValue()\n    ? (column.getFilterValue() as FilterValue<'text', TData>)\n    : undefined\n\n  if (!filter) return null\n  if (filter.values.length === 0 || filter.values[0].trim() === '')\n    return <Ellipsis className=\"size-4\" />\n\n  const value = filter.values[0]\n\n  return <span>{value}</span>\n}\n\nexport function PropertyFilterNumberValueDisplay<TData, TValue>({\n  column,\n  columnMeta,\n}: PropertyFilterValueDisplayProps<TData, TValue>) {\n  const maxFromMeta = columnMeta.max\n  const cappedMax = maxFromMeta ?? 2147483647\n\n  const filter = column.getFilterValue()\n    ? (column.getFilterValue() as FilterValue<'number', TData>)\n    : undefined\n\n  if (!filter) return null\n\n  if (\n    filter.operator === 'is between' ||\n    filter.operator === 'is not between'\n  ) {\n    const minValue = filter.values[0]\n    const maxValue =\n      filter.values[1] === Number.POSITIVE_INFINITY ||\n        filter.values[1] >= cappedMax\n        ? `${cappedMax}+`\n        : filter.values[1]\n\n    return (\n      <span className=\"tabular-nums tracking-tight\">\n        {minValue} and {maxValue}\n      </span>\n    )\n  }\n\n  if (!filter.values || filter.values.length === 0) {\n    return null\n  }\n\n  const value = filter.values[0]\n  return <span className=\"tabular-nums tracking-tight\">{value}</span>\n}\n\nexport function PropertyFilterValueMenu<TData, TValue>({\n  id,\n  column,\n  columnMeta,\n  table,\n}: {\n  id: string\n  column: Column<TData>\n  columnMeta: ColumnMeta<TData, TValue>\n  table: Table<TData>\n}) {\n  switch (columnMeta.type) {\n    case 'option':\n      return (\n        <PropertyFilterOptionValueMenu\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    case 'multiOption':\n      return (\n        <PropertyFilterMultiOptionValueMenu\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    case 'date':\n      return (\n        <PropertyFilterDateValueMenu\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    case 'text':\n      return (\n        <PropertyFilterTextValueMenu\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    case 'number':\n      return (\n        <PropertyFilterNumberValueMenu\n          id={id}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      )\n    default:\n      return null\n  }\n}\n\ninterface ProperFilterValueMenuProps<TData, TValue> {\n  id: string\n  column: Column<TData>\n  columnMeta: ColumnMeta<TData, TValue>\n  table: Table<TData>\n}\n\nexport function PropertyFilterOptionValueMenu<TData, TValue>({\n  id,\n  column,\n  columnMeta,\n  table,\n}: ProperFilterValueMenuProps<TData, TValue>) {\n  const filter = column.getFilterValue()\n    ? (column.getFilterValue() as FilterValue<'option', TData>)\n    : undefined\n\n  let options: ColumnOption[]\n  const columnVals = table\n    .getCoreRowModel()\n    .rows.flatMap((r) => r.getValue<TValue>(id))\n    .filter((v): v is NonNullable<TValue> => v !== undefined && v !== null)\n\n  // If static options are provided, use them\n  if (columnMeta.options) {\n    options = columnMeta.options\n  }\n\n  // No static options provided,\n  // We should dynamically generate them based on the column data\n  else if (columnMeta.transformOptionFn) {\n    const transformOptionFn = columnMeta.transformOptionFn\n\n    const unique = uniq(columnVals)\n\n    options = unique.map((v) =>\n      transformOptionFn(v as ElementType<NonNullable<TValue>>),\n    )\n  }\n\n  // No static options provided\n  // Missing transformOptionFn - throw error\n  else {\n    throw new Error(\n      'No options provided - this is required for multiOption data type without static options',\n    )\n  }\n\n  const optionsCount: Record<ColumnOption['value'], number> = columnVals.reduce(\n    (acc, curr) => {\n      const { value } = columnMeta.transformOptionFn\n        ? columnMeta.transformOptionFn(curr as ElementType<NonNullable<TValue>>)\n        : { value: curr as string }\n\n      acc[value] = (acc[value] ?? 0) + 1\n      return acc\n    },\n    {} as Record<ColumnOption['value'], number>,\n  )\n\n  function handleOptionSelect(value: string, check: boolean) {\n    if (check)\n      column?.setFilterValue(\n        (old: undefined | FilterValue<'option', TData>) => {\n          if (!old || old.values.length === 0)\n            return {\n              operator: 'is',\n              values: [value],\n              column,\n            } satisfies FilterValue<'option', TData>\n\n          const newValues = [...old.values, value]\n\n          return {\n            operator: 'is any of',\n            values: newValues,\n            column,\n          } satisfies FilterValue<'option', TData>\n        },\n      )\n    else\n      column?.setFilterValue(\n        (old: undefined | FilterValue<'option', TData>) => {\n          if (!old || old.values.length <= 1) return undefined\n\n          const newValues = old.values.filter((v) => v !== value)\n          return {\n            operator: newValues.length > 1 ? 'is any of' : 'is',\n            values: newValues,\n            column,\n          } satisfies FilterValue<'option', TData>\n        },\n      )\n  }\n\n  return (\n    <Command loop>\n      <CommandInput autoFocus placeholder=\"Search...\" />\n      <CommandEmpty>No results.</CommandEmpty>\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup>\n          {options.map((v) => {\n            const checked = Boolean(filter?.values.includes(v.value))\n            const count = optionsCount[v.value] ?? 0\n\n            return (\n              <CommandItem\n                key={v.value}\n                onSelect={() => {\n                  handleOptionSelect(v.value, !checked)\n                }}\n                className=\"group flex items-center justify-between gap-1.5\"\n              >\n                <div className=\"flex items-center gap-1.5\">\n                  <Checkbox\n                    checked={checked}\n                    className=\"opacity-0 group-hover:opacity-100 data-[state=checked]:opacity-100\"\n                  />\n                  {v.icon &&\n                    (isValidElement(v.icon) ? (\n                      v.icon\n                    ) : (\n                      <v.icon className=\"size-4 text-primary\" />\n                    ))}\n                  <span>\n                    {v.label}\n                    <sup\n                      className={cn(\n                        'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\n                        count === 0 && 'slashed-zero',\n                      )}\n                    >\n                      {count < 100 ? count : '100+'}\n                    </sup>\n                  </span>\n                </div>\n              </CommandItem>\n            )\n          })}\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function PropertyFilterMultiOptionValueMenu<\n  TData extends RowData,\n  TValue,\n>({\n  id,\n  column,\n  columnMeta,\n  table,\n}: ProperFilterValueMenuProps<TData, TValue>) {\n  const filter = column.getFilterValue() as\n    | FilterValue<'multiOption', TData>\n    | undefined\n\n  let options: ColumnOption[]\n  const columnVals = table\n    .getCoreRowModel()\n    .rows.flatMap((r) => r.getValue<TValue>(id))\n    .filter((v): v is NonNullable<TValue> => v !== undefined && v !== null)\n\n  // If static options are provided, use them\n  if (columnMeta.options) {\n    options = columnMeta.options\n  }\n\n  // No static options provided,\n  // We should dynamically generate them based on the column data\n  else if (columnMeta.transformOptionFn) {\n    const transformOptionFn = columnMeta.transformOptionFn\n\n    const unique = uniq(columnVals)\n\n    options = unique.map((v) =>\n      transformOptionFn(v as ElementType<NonNullable<TValue>>),\n    )\n  }\n\n  // No static options provided\n  // Missing transformOptionFn - throw error\n  else {\n    throw new Error(\n      'No options provided - this is required for multiOption data type without static options',\n    )\n  }\n\n  const optionsCount: Record<ColumnOption['value'], number> = columnVals.reduce(\n    (acc, curr) => {\n      const { value } = columnMeta.transformOptionFn!(\n        curr as ElementType<NonNullable<TValue>>,\n      )\n\n      acc[value] = (acc[value] ?? 0) + 1\n      return acc\n    },\n    {} as Record<ColumnOption['value'], number>,\n  )\n\n  // Handles the selection/deselection of an option\n  function handleOptionSelect(value: string, check: boolean) {\n    if (check) {\n      column.setFilterValue(\n        (old: undefined | FilterValue<'multiOption', TData>) => {\n          if (\n            !old ||\n            old.values.length === 0 ||\n            !old.values[0] ||\n            old.values[0].length === 0\n          )\n            return {\n              operator: 'include',\n              values: [[value]],\n              column,\n            } satisfies FilterValue<'multiOption', TData>\n\n          const newValues = [uniq([...old.values[0], value])]\n\n          return {\n            operator: determineNewOperator(\n              'multiOption',\n              old.values,\n              newValues,\n              old.operator,\n            ),\n            values: newValues,\n            column,\n          } satisfies FilterValue<'multiOption', TData>\n        },\n      )\n    } else\n      column.setFilterValue(\n        (old: undefined | FilterValue<'multiOption', TData>) => {\n          if (!old?.values[0] || old.values[0].length <= 1) return undefined\n\n          const newValues = [\n            uniq([...old.values[0], value]).filter((v) => v !== value),\n          ]\n\n          return {\n            operator: determineNewOperator(\n              'multiOption',\n              old.values,\n              newValues,\n              old.operator,\n            ),\n            values: newValues,\n            column,\n          } satisfies FilterValue<'multiOption', TData>\n        },\n      )\n  }\n\n  return (\n    <Command loop>\n      <CommandInput autoFocus placeholder=\"Search...\" />\n      <CommandEmpty>No results.</CommandEmpty>\n      <CommandList>\n        <CommandGroup>\n          {options.map((v) => {\n            const checked = Boolean(filter?.values[0]?.includes(v.value))\n            const count = optionsCount[v.value] ?? 0\n\n            return (\n              <CommandItem\n                key={v.value}\n                onSelect={() => {\n                  handleOptionSelect(v.value, !checked)\n                }}\n                className=\"group flex items-center justify-between gap-1.5\"\n              >\n                <div className=\"flex items-center gap-1.5\">\n                  <Checkbox\n                    checked={checked}\n                    className=\"opacity-0 group-hover:opacity-100 data-[state=checked]:opacity-100\"\n                  />\n                  {v.icon &&\n                    (isValidElement(v.icon) ? (\n                      v.icon\n                    ) : (\n                      <v.icon className=\"size-4 text-primary\" />\n                    ))}\n                  <span>\n                    {v.label}\n                    <sup\n                      className={cn(\n                        'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\n                        count === 0 && 'slashed-zero',\n                      )}\n                    >\n                      {count < 100 ? count : '100+'}\n                    </sup>\n                  </span>\n                </div>\n              </CommandItem>\n            )\n          })}\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function PropertyFilterDateValueMenu<TData, TValue>({\n  column,\n}: ProperFilterValueMenuProps<TData, TValue>) {\n  const filter = column.getFilterValue()\n    ? (column.getFilterValue() as FilterValue<'date', TData>)\n    : undefined\n\n  const [date, setDate] = useState<DateRange | undefined>({\n    from: filter?.values[0] ?? new Date(),\n    to: filter?.values[1] ?? undefined,\n  })\n\n  function changeDateRange(value: DateRange | undefined) {\n    const start = value?.from\n    const end =\n      start && value && value.to && !isEqual(start, value.to)\n        ? value.to\n        : undefined\n\n    setDate({ from: start, to: end })\n\n    const isRange = start && end\n\n    const newValues = isRange ? [start, end] : start ? [start] : []\n\n    column.setFilterValue((old: undefined | FilterValue<'date', TData>) => {\n      if (!old || old.values.length === 0)\n        return {\n          operator: newValues.length > 1 ? 'is between' : 'is',\n          values: newValues,\n          column,\n        } satisfies FilterValue<'date', TData>\n\n      return {\n        operator:\n          old.values.length < newValues.length\n            ? 'is between'\n            : old.values.length > newValues.length\n              ? 'is'\n              : old.operator,\n        values: newValues,\n        column,\n      } satisfies FilterValue<'date', TData>\n    })\n  }\n\n  return (\n    <Command>\n      {/* <CommandInput placeholder=\"Search...\" /> */}\n      {/* <CommandEmpty>No results.</CommandEmpty> */}\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup>\n          <div>\n            <Calendar\n              initialFocus\n              mode=\"range\"\n              defaultMonth={date?.from}\n              selected={date}\n              onSelect={changeDateRange}\n              numberOfMonths={1}\n            />\n          </div>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function PropertyFilterTextValueMenu<TData, TValue>({\n  column,\n}: ProperFilterValueMenuProps<TData, TValue>) {\n  const filter = column.getFilterValue()\n    ? (column.getFilterValue() as FilterValue<'text', TData>)\n    : undefined\n\n  const changeText = (value: string | number) => {\n    column.setFilterValue((old: undefined | FilterValue<'text', TData>) => {\n      if (!old || old.values.length === 0)\n        return {\n          operator: 'contains',\n          values: [String(value)],\n          column,\n        } satisfies FilterValue<'text', TData>\n      return { operator: old.operator, values: [String(value)] }\n    })\n  }\n\n  return (\n    <Command>\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup>\n          <CommandItem>\n            <DebouncedInput\n              placeholder=\"Search...\"\n              autoFocus\n              value={filter?.values[0] ?? ''}\n              onChange={changeText}\n            />\n          </CommandItem>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function PropertyFilterNumberValueMenu<TData, TValue>({\n  table,\n  column,\n  columnMeta,\n}: ProperFilterValueMenuProps<TData, TValue>) {\n  const maxFromMeta = columnMeta.max\n  const cappedMax = maxFromMeta ?? Number.MAX_SAFE_INTEGER\n\n  const filter = column.getFilterValue()\n    ? (column.getFilterValue() as FilterValue<'number', TData>)\n    : undefined\n\n  const isNumberRange =\n    !!filter && numberFilterDetails[filter.operator].target === 'multiple'\n\n  const [datasetMin] = column.getFacetedMinMaxValues() ?? [0, 0]\n\n  const initialValues = () => {\n    if (filter?.values) {\n      return filter.values.map((val) =>\n        val >= cappedMax ? `${cappedMax}+` : val.toString(),\n      )\n    }\n    return [datasetMin.toString()]\n  }\n\n  const [inputValues, setInputValues] = useState<string[]>(initialValues)\n\n  const changeNumber = (value: number[]) => {\n    const sortedValues = [...value].sort((a, b) => a - b)\n\n    column.setFilterValue((old: undefined | FilterValue<'number', TData>) => {\n      if (!old || old.values.length === 0) {\n        return {\n          operator: 'is',\n          values: sortedValues,\n        }\n      }\n\n      const operator = numberFilterDetails[old.operator]\n      let newValues: number[]\n\n      if (operator.target === 'single') {\n        newValues = [sortedValues[0]]\n      } else {\n        newValues = [\n          sortedValues[0] >= cappedMax ? cappedMax : sortedValues[0],\n          sortedValues[1] >= cappedMax\n            ? Number.POSITIVE_INFINITY\n            : sortedValues[1],\n        ]\n      }\n\n      return {\n        operator: old.operator,\n        values: newValues,\n      }\n    })\n  }\n\n  const handleInputChange = (index: number, value: string) => {\n    const newValues = [...inputValues]\n    if (isNumberRange && Number.parseInt(value, 10) >= cappedMax) {\n      newValues[index] = `${cappedMax}+`\n    } else {\n      newValues[index] = value\n    }\n\n    setInputValues(newValues)\n\n    const parsedValues = newValues.map((val) => {\n      if (val.trim() === '') return 0\n      if (val === `${cappedMax}+`) return cappedMax\n      return Number.parseInt(val, 10)\n    })\n\n    changeNumber(parsedValues)\n  }\n\n  const changeType = (type: 'single' | 'range') => {\n    column.setFilterValue((old: undefined | FilterValue<'number', TData>) => {\n      if (type === 'single') {\n        return {\n          operator: 'is',\n          values: [old?.values[0] ?? 0],\n        }\n      }\n      const newMaxValue = old?.values[0] ?? cappedMax\n      return {\n        operator: 'is between',\n        values: [0, newMaxValue],\n      }\n    })\n\n    if (type === 'single') {\n      setInputValues([inputValues[0]])\n    } else {\n      const maxValue = inputValues[0] || cappedMax.toString()\n      setInputValues(['0', maxValue])\n    }\n  }\n\n  const slider = {\n    value: inputValues.map((val) =>\n      val === '' || val === `${cappedMax}+`\n        ? cappedMax\n        : Number.parseInt(val, 10),\n    ),\n    onValueChange: (value: number[]) => {\n      const values = value.map((val) => (val >= cappedMax ? cappedMax : val))\n      setInputValues(\n        values.map((v) => (v >= cappedMax ? `${cappedMax}+` : v.toString())),\n      )\n      changeNumber(values)\n    },\n  }\n\n  return (\n    <Command>\n      <CommandList className=\"w-[300px] px-2 py-2\">\n        <CommandGroup>\n          <div className=\"flex flex-col w-full\">\n            <Tabs\n              value={isNumberRange ? 'range' : 'single'}\n              onValueChange={(v) =>\n                changeType(v === 'range' ? 'range' : 'single')\n              }\n            >\n              <TabsList className=\"w-full *:text-xs\">\n                <TabsTrigger value=\"single\">Single</TabsTrigger>\n                <TabsTrigger value=\"range\">Range</TabsTrigger>\n              </TabsList>\n              <TabsContent value=\"single\" className=\"flex flex-col gap-4 mt-4\">\n                <Slider\n                  value={[Number(inputValues[0])]}\n                  onValueChange={(value) => {\n                    handleInputChange(0, value[0].toString())\n                  }}\n                  min={datasetMin}\n                  max={cappedMax}\n                  step={1}\n                  aria-orientation=\"horizontal\"\n                />\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"text-xs font-medium\">Value</span>\n                  <Input\n                    id=\"single\"\n                    type=\"number\"\n                    value={inputValues[0]}\n                    onChange={(e) => handleInputChange(0, e.target.value)}\n                    max={cappedMax}\n                  />\n                </div>\n              </TabsContent>\n              <TabsContent value=\"range\" className=\"flex flex-col gap-4 mt-4\">\n                <Slider\n                  value={slider.value}\n                  onValueChange={slider.onValueChange}\n                  min={datasetMin}\n                  max={cappedMax}\n                  step={1}\n                  aria-orientation=\"horizontal\"\n                />\n                <div className=\"grid grid-cols-2 gap-4\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-xs font-medium\">Min</span>\n                    <Input\n                      type=\"number\"\n                      value={inputValues[0]}\n                      onChange={(e) => handleInputChange(0, e.target.value)}\n                      max={cappedMax}\n                    />\n                  </div>\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-xs font-medium\">Max</span>\n                    <Input\n                      type=\"text\"\n                      value={inputValues[1]}\n                      placeholder={`${cappedMax}+`}\n                      onChange={(e) => handleInputChange(1, e.target.value)}\n                      max={cappedMax}\n                    />\n                  </div>\n                </div>\n              </TabsContent>\n            </Tabs>\n          </div>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/components/table-filter-actions.tsx",
      "content": "import { Button } from '@/components/ui/button'\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '@/components/ui/tooltip'\nimport { cn } from '@/lib/utils'\nimport type { Table } from '@tanstack/react-table'\nimport { FilterX } from 'lucide-react'\n\nexport function TableFilterActions<TData>({ table }: { table: Table<TData> }) {\n  const hasFilters = table.getState().columnFilters.length > 0\n\n  function clearFilters() {\n    table.setColumnFilters([])\n    table.setGlobalFilter('')\n  }\n\n  return (\n    <TooltipProvider>\n      <Tooltip>\n        <TooltipTrigger asChild>\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            className={cn(\n              'h-7 w-fit border-red-600 px-2 font-normal text-red-600 hover:bg-red-600/10 hover:text-red-600',\n              !hasFilters && 'hidden',\n            )}\n            onClick={clearFilters}\n          >\n            <FilterX className=\"size-4\" />\n            <span className=\"ml-1 whitespace-nowrap\">Clear</span>\n          </Button>\n        </TooltipTrigger>\n        <TooltipContent>Clear all filters</TooltipContent>\n      </Tooltip>\n    </TooltipProvider>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/components/table-filter-menu.tsx",
      "content": "'use client'\n\nimport { Button } from '@/components/ui/button'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport { cn } from '@/lib/utils'\nimport {\n  getColumn,\n  getColumnMeta,\n} from '@/registry/data-table-filter/lib/table'\nimport type { Column, Table } from '@tanstack/react-table'\nimport { ArrowRight, Filter } from 'lucide-react'\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport { PropertyFilterValueMenu } from './property-filter-value'\n\nexport function TableFilter<TData>({ table }: { table: Table<TData> }) {\n  const [open, setOpen] = useState(false)\n  const [value, setValue] = useState('')\n  const [property, setProperty] = useState<string | undefined>(undefined)\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  const column = property ? getColumn(table, property) : undefined\n  const columnMeta = property ? getColumnMeta(table, property) : undefined\n\n  const properties = table\n    .getAllColumns()\n    .filter((column) => column.getCanFilter())\n\n  const hasFilters = table.getState().columnFilters.length > 0\n\n  useEffect(() => {\n    if (property && inputRef) {\n      inputRef.current?.focus()\n      setValue('')\n    }\n  }, [property])\n\n  useEffect(() => {\n    if (!open) setTimeout(() => setValue(''), 150)\n  }, [open])\n\n  const content = useMemo(\n    () =>\n      property && column && columnMeta ? (\n        <PropertyFilterValueMenu\n          id={property}\n          column={column}\n          columnMeta={columnMeta}\n          table={table}\n        />\n      ) : (\n        <Command loop>\n          <CommandInput\n            value={value}\n            onValueChange={setValue}\n            ref={inputRef}\n            placeholder=\"Search...\"\n          />\n          <CommandEmpty>No results.</CommandEmpty>\n          <CommandList className=\"max-h-fit\">\n            <CommandGroup>\n              {properties.map((column) => (\n                <TableFilterMenuItem\n                  key={column.id}\n                  column={column}\n                  table={table}\n                  setProperty={setProperty}\n                />\n              ))}\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      ),\n    [property, column, columnMeta, value, table, properties],\n  )\n\n  return (\n    <Popover\n      open={open}\n      onOpenChange={async (value) => {\n        setOpen(value)\n        if (!value) setTimeout(() => setProperty(undefined), 100)\n      }}\n    >\n      <PopoverTrigger asChild>\n        <Button variant=\"outline\" className={cn('h-7', hasFilters && 'w-fit')}>\n          <Filter className=\"size-4\" />\n          {!hasFilters && <span>Filter</span>}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        {content}\n      </PopoverContent>\n    </Popover>\n  )\n}\n\nexport function TableFilterMenuItem<TData>({\n  column,\n  setProperty,\n}: {\n  column: Column<TData>\n  table: Table<TData>\n  setProperty: (value: string) => void\n}) {\n  const Icon = column.columnDef.meta?.icon!\n  return (\n    <CommandItem onSelect={() => setProperty(column.id)} className=\"group\">\n      <div className=\"flex w-full items-center justify-between\">\n        <div className=\"inline-flex items-center gap-1.5\">\n          {<Icon strokeWidth={2.25} className=\"size-4\" />}\n          <span>{column.columnDef.meta?.displayName}</span>\n        </div>\n        <ArrowRight className=\"size-4 opacity-0 group-aria-selected:opacity-100\" />\n      </div>\n    </CommandItem>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/lib/array.ts",
      "content": "export function intersection<T>(a: T[], b: T[]): T[] {\n  return a.filter((x) => b.includes(x))\n}\n\nexport function uniq<T>(a: T[]): T[] {\n  return Array.from(new Set(a))\n}\n\nexport function take<T>(a: T[], n: number): T[] {\n  return a.slice(0, n)\n}\n\nexport function flatten<T>(a: T[][]): T[] {\n  return a.flat()\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/data-table-filter/lib/filters.ts",
      "content": "import '@tanstack/table-core'\nimport { type RankingInfo, rankItem } from '@tanstack/match-sorter-utils'\nimport type { Column, FilterFn, Row, RowData } from '@tanstack/react-table'\nimport type { ColumnMeta } from '@tanstack/react-table'\nimport {\n  endOfDay,\n  isAfter,\n  isBefore,\n  isSameDay,\n  isWithinInterval,\n  startOfDay,\n} from 'date-fns'\nimport type { LucideIcon } from 'lucide-react'\nimport { intersection, uniq } from './array'\n\nexport type ElementType<T> = T extends (infer U)[] ? U : T\n\ndeclare module '@tanstack/react-table' {\n  interface ColumnMeta<TData extends RowData, TValue> {\n    /* The display name of the column. */\n    displayName: string\n\n    /* The column icon. */\n    icon: LucideIcon\n\n    /* The data type of the column. */\n    type: ColumnDataType\n\n    /* Optional */\n    /* Max number for range slider */\n    /* Only works with number type */\n    max?: number\n\n    /* An optional list of options for the column. */\n    /* This is used for columns with type 'option' or 'multiOption'. */\n    /* If the options are known ahead of time, they can be defined here. */\n    /* Otherwise, they will be dynamically generated based on the data. */\n    options?: ColumnOption[]\n\n    /* An optional function to transform the column value before filtering. */\n    /* This can be used to convert the column value to the column data type's native value. */\n    /* Native types for each data type are defined in the FilterTypes interface. */\n    transformFn?: (\n      value: Exclude<TValue, undefined | null>,\n    ) => FilterTypes[ColumnDataType]\n\n    /* An optional function to transform columns with type 'option' or 'multiOption'. */\n    /* This is used to convert each raw option into a ColumnOption. */\n    transformOptionFn?: (\n      value: ElementType<NonNullable<TValue>>,\n    ) => ColumnOption\n  }\n}\n\n// Helper function\nexport function defineMeta<\n  TData extends RowData,\n  TValue,\n  TType extends ColumnDataType,\n>(\n  meta: Omit<ColumnMeta<TData, TValue>, 'type' | 'transformFn'> & {\n    type: TType\n    transformFn?: (\n      value: Exclude<TValue, undefined | null>,\n    ) => FilterTypes[TType]\n  },\n): ColumnMeta<TData, TValue> {\n  return meta\n}\n\ndeclare module '@tanstack/table-core' {\n  interface FilterFns {\n    fuzzy: FilterFn<unknown>\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo\n  }\n}\n\nexport const fuzzyFilter: FilterFn<unknown> = (\n  row,\n  columnId,\n  value,\n  addMeta,\n) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value)\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  })\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed\n}\n\n/*\n * Represents a possible value for a column property of type 'option' or 'multiOption'.\n */\nexport interface ColumnOption {\n  /* The label to display for the option. */\n  label: string\n  /* The internal value of the option. */\n  value: string\n  /* An optional icon to display next to the label. */\n  icon?: React.ReactElement | React.ElementType\n}\n\n/*\n * Represents the data type of a column.\n */\nexport type ColumnDataType =\n  /* The column value is a string that should be searchable. */\n  | 'text'\n  | 'number'\n  | 'date'\n  /* The column value can be a single value from a list of options. */\n  | 'option'\n  /* The column value can be zero or more values from a list of options. */\n  | 'multiOption'\n\n/* Operators for text data */\nexport type TextFilterOperator = 'contains' | 'does not contain'\n\n/* Operators for number data */\nexport type NumberFilterOperator =\n  | 'is'\n  | 'is not'\n  | 'is less than'\n  | 'is greater than or equal to'\n  | 'is greater than'\n  | 'is less than or equal to'\n  | 'is between'\n  | 'is not between'\n\n/* Operators for date data */\nexport type DateFilterOperator =\n  | 'is'\n  | 'is not'\n  | 'is before'\n  | 'is on or after'\n  | 'is after'\n  | 'is on or before'\n  | 'is between'\n  | 'is not between'\n\n/* Operators for option data */\nexport type OptionFilterOperator = 'is' | 'is not' | 'is any of' | 'is none of'\n\n/* Operators for multi-option data */\nexport type MultiOptionFilterOperator =\n  | 'include'\n  | 'exclude'\n  | 'include any of'\n  | 'include all of'\n  | 'exclude if any of'\n  | 'exclude if all'\n\n/* Maps filter operators to their respective data types */\ntype FilterOperators = {\n  text: TextFilterOperator\n  number: NumberFilterOperator\n  date: DateFilterOperator\n  option: OptionFilterOperator\n  multiOption: MultiOptionFilterOperator\n}\n\n/* Maps filter values to their respective data types */\nexport type FilterTypes = {\n  text: string\n  number: number\n  date: Date\n  option: string\n  multiOption: string[]\n}\n\n/*\n *\n * FilterValue is a type that represents a filter value for a specific column.\n *\n * It consists of:\n * - Operator: The operator to be used for the filter.\n * - Values: An array of values to be used for the filter.\n *\n */\nexport type FilterValue<T extends ColumnDataType, TData> = {\n  operator: FilterOperators[T]\n  values: Array<FilterTypes[T]>\n  column: Column<TData>\n}\n\n/*\n * FilterDetails is a type that represents the details of all the filter operators for a specific column data type.\n */\nexport type FilterDetails<T extends ColumnDataType> = {\n  [key in FilterOperators[T]]: FilterOperatorDetails<key, T>\n}\n\ntype FilterOperatorDetailsBase<OperatorValue, T extends ColumnDataType> = {\n  /* The operator value. Usually the string representation of the operator. */\n  value: OperatorValue\n  /* The label for the operator, to show in the UI. */\n  label: string\n  /* How much data the operator applies to. */\n  target: 'single' | 'multiple'\n  /* The plural form of the operator, if applicable. */\n  singularOf?: FilterOperators[T]\n  /* The singular form of the operator, if applicable. */\n  pluralOf?: FilterOperators[T]\n  /* All related operators. Normally, all the operators which share the same target. */\n  relativeOf: FilterOperators[T] | Array<FilterOperators[T]>\n  /* Whether the operator is negated. */\n  isNegated: boolean\n  /* If the operator is not negated, this provides the negated equivalent. */\n  negation?: FilterOperators[T]\n  /* If the operator is negated, this provides the positive equivalent. */\n  negationOf?: FilterOperators[T]\n}\n\n/*\n *\n * FilterOperatorDetails is a type that provides details about a filter operator for a specific column data type.\n * It extends FilterOperatorDetailsBase with additional logic and contraints on the defined properties.\n *\n */\nexport type FilterOperatorDetails<\n  OperatorValue,\n  T extends ColumnDataType,\n> = FilterOperatorDetailsBase<OperatorValue, T> &\n  (\n    | { singularOf?: never; pluralOf?: never }\n    | { target: 'single'; singularOf: FilterOperators[T]; pluralOf?: never }\n    | { target: 'multiple'; singularOf?: never; pluralOf: FilterOperators[T] }\n  ) &\n  (\n    | { isNegated: false; negation: FilterOperators[T]; negationOf?: never }\n    | { isNegated: true; negation?: never; negationOf: FilterOperators[T] }\n  )\n\n/* Details for all the filter operators for option data type */\nexport const optionFilterDetails = {\n  is: {\n    label: 'is',\n    value: 'is',\n    target: 'single',\n    singularOf: 'is not',\n    relativeOf: 'is any of',\n    isNegated: false,\n    negation: 'is not',\n  },\n  'is not': {\n    label: 'is not',\n    value: 'is not',\n    target: 'single',\n    singularOf: 'is',\n    relativeOf: 'is none of',\n    isNegated: true,\n    negationOf: 'is',\n  },\n  'is any of': {\n    label: 'is any of',\n    value: 'is any of',\n    target: 'multiple',\n    pluralOf: 'is',\n    relativeOf: 'is',\n    isNegated: false,\n    negation: 'is none of',\n  },\n  'is none of': {\n    label: 'is none of',\n    value: 'is none of',\n    target: 'multiple',\n    pluralOf: 'is not',\n    relativeOf: 'is not',\n    isNegated: true,\n    negationOf: 'is any of',\n  },\n} as const satisfies FilterDetails<'option'>\n\n/* Details for all the filter operators for multi-option data type */\nexport const multiOptionFilterDetails = {\n  include: {\n    label: 'include',\n    value: 'include',\n    target: 'single',\n    singularOf: 'include any of',\n    relativeOf: 'exclude',\n    isNegated: false,\n    negation: 'exclude',\n  },\n  exclude: {\n    label: 'exclude',\n    value: 'exclude',\n    target: 'single',\n    singularOf: 'exclude if any of',\n    relativeOf: 'include',\n    isNegated: true,\n    negationOf: 'include',\n  },\n  'include any of': {\n    label: 'include any of',\n    value: 'include any of',\n    target: 'multiple',\n    pluralOf: 'include',\n    relativeOf: ['exclude if all', 'include all of', 'exclude if any of'],\n    isNegated: false,\n    negation: 'exclude if all',\n  },\n  'exclude if all': {\n    label: 'exclude if all',\n    value: 'exclude if all',\n    target: 'multiple',\n    pluralOf: 'exclude',\n    relativeOf: ['include any of', 'include all of', 'exclude if any of'],\n    isNegated: true,\n    negationOf: 'include any of',\n  },\n  'include all of': {\n    label: 'include all of',\n    value: 'include all of',\n    target: 'multiple',\n    pluralOf: 'include',\n    relativeOf: ['include any of', 'exclude if all', 'exclude if any of'],\n    isNegated: false,\n    negation: 'exclude if any of',\n  },\n  'exclude if any of': {\n    label: 'exclude if any of',\n    value: 'exclude if any of',\n    target: 'multiple',\n    pluralOf: 'exclude',\n    relativeOf: ['include any of', 'exclude if all', 'include all of'],\n    isNegated: true,\n    negationOf: 'include all of',\n  },\n} as const satisfies FilterDetails<'multiOption'>\n\n/* Details for all the filter operators for date data type */\nexport const dateFilterDetails = {\n  is: {\n    label: 'is',\n    value: 'is',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: 'is after',\n    isNegated: false,\n    negation: 'is before',\n  },\n  'is not': {\n    label: 'is not',\n    value: 'is not',\n    target: 'single',\n    singularOf: 'is not between',\n    relativeOf: [\n      'is',\n      'is before',\n      'is on or after',\n      'is after',\n      'is on or before',\n    ],\n    isNegated: true,\n    negationOf: 'is',\n  },\n  'is before': {\n    label: 'is before',\n    value: 'is before',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is',\n      'is not',\n      'is on or after',\n      'is after',\n      'is on or before',\n    ],\n    isNegated: false,\n    negation: 'is on or after',\n  },\n  'is on or after': {\n    label: 'is on or after',\n    value: 'is on or after',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: ['is', 'is not', 'is before', 'is after', 'is on or before'],\n    isNegated: false,\n    negation: 'is before',\n  },\n  'is after': {\n    label: 'is after',\n    value: 'is after',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is',\n      'is not',\n      'is before',\n      'is on or after',\n      'is on or before',\n    ],\n    isNegated: false,\n    negation: 'is on or before',\n  },\n  'is on or before': {\n    label: 'is on or before',\n    value: 'is on or before',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: ['is', 'is not', 'is after', 'is on or after', 'is before'],\n    isNegated: false,\n    negation: 'is after',\n  },\n  'is between': {\n    label: 'is between',\n    value: 'is between',\n    target: 'multiple',\n    pluralOf: 'is',\n    relativeOf: 'is not between',\n    isNegated: false,\n    negation: 'is not between',\n  },\n  'is not between': {\n    label: 'is not between',\n    value: 'is not between',\n    target: 'multiple',\n    pluralOf: 'is not',\n    relativeOf: 'is between',\n    isNegated: true,\n    negationOf: 'is between',\n  },\n} as const satisfies FilterDetails<'date'>\n\n/* Details for all the filter operators for text data type */\nexport const textFilterDetails = {\n  contains: {\n    label: 'contains',\n    value: 'contains',\n    target: 'single',\n    relativeOf: 'does not contain',\n    isNegated: false,\n    negation: 'does not contain',\n  },\n  'does not contain': {\n    label: 'does not contain',\n    value: 'does not contain',\n    target: 'single',\n    relativeOf: 'contains',\n    isNegated: true,\n    negationOf: 'contains',\n  },\n} as const satisfies FilterDetails<'text'>\n\n/* Details for all the filter operators for number data type */\nexport const numberFilterDetails = {\n  is: {\n    label: 'is',\n    value: 'is',\n    target: 'single',\n    relativeOf: [\n      'is not',\n      'is greater than',\n      'is less than or equal to',\n      'is less than',\n      'is greater than or equal to',\n    ],\n    isNegated: false,\n    negation: 'is not',\n  },\n  'is not': {\n    label: 'is not',\n    value: 'is not',\n    target: 'single',\n    relativeOf: [\n      'is',\n      'is greater than',\n      'is less than or equal to',\n      'is less than',\n      'is greater than or equal to',\n    ],\n    isNegated: true,\n    negationOf: 'is',\n  },\n  'is greater than': {\n    label: '>',\n    value: 'is greater than',\n    target: 'single',\n    relativeOf: [\n      'is',\n      'is not',\n      'is less than or equal to',\n      'is less than',\n      'is greater than or equal to',\n    ],\n    isNegated: false,\n    negation: 'is less than or equal to',\n  },\n  'is greater than or equal to': {\n    label: '>=',\n    value: 'is greater than or equal to',\n    target: 'single',\n    relativeOf: [\n      'is',\n      'is not',\n      'is greater than',\n      'is less than or equal to',\n      'is less than',\n    ],\n    isNegated: false,\n    negation: 'is less than or equal to',\n  },\n  'is less than': {\n    label: '<',\n    value: 'is less than',\n    target: 'single',\n    relativeOf: [\n      'is',\n      'is not',\n      'is greater than',\n      'is less than or equal to',\n      'is greater than or equal to',\n    ],\n    isNegated: false,\n    negation: 'is greater than',\n  },\n  'is less than or equal to': {\n    label: '<=',\n    value: 'is less than or equal to',\n    target: 'single',\n    relativeOf: [\n      'is',\n      'is not',\n      'is greater than',\n      'is less than',\n      'is greater than or equal to',\n    ],\n    isNegated: false,\n    negation: 'is greater than or equal to',\n  },\n  'is between': {\n    label: 'is between',\n    value: 'is between',\n    target: 'multiple',\n    relativeOf: 'is not between',\n    isNegated: false,\n    negation: 'is not between',\n  },\n  'is not between': {\n    label: 'is not between',\n    value: 'is not between',\n    target: 'multiple',\n    relativeOf: 'is between',\n    isNegated: true,\n    negationOf: 'is between',\n  },\n} as const satisfies FilterDetails<'number'>\n\n/* Maps column data types to their respective filter operator details */\ntype FilterTypeOperatorDetails = {\n  [key in ColumnDataType]: FilterDetails<key>\n}\n\nexport const filterTypeOperatorDetails: FilterTypeOperatorDetails = {\n  text: textFilterDetails,\n  number: numberFilterDetails,\n  date: dateFilterDetails,\n  option: optionFilterDetails,\n  multiOption: multiOptionFilterDetails,\n}\n\n/*\n *\n * Determines the new operator for a filter based on the current operator, old and new filter values.\n *\n * This handles cases where the filter values have transitioned from a single value to multiple values (or vice versa),\n * and the current operator needs to be transitioned to its plural form (or singular form).\n *\n * For example, if the current operator is 'is', and the new filter values have a length of 2, the\n * new operator would be 'is any of'.\n *\n */\nexport function determineNewOperator<T extends ColumnDataType>(\n  type: T,\n  oldVals: Array<FilterTypes[T]>,\n  nextVals: Array<FilterTypes[T]>,\n  currentOperator: FilterOperators[T],\n): FilterOperators[T] {\n  const a =\n    Array.isArray(oldVals) && Array.isArray(oldVals[0])\n      ? oldVals[0].length\n      : oldVals.length\n  const b =\n    Array.isArray(nextVals) && Array.isArray(nextVals[0])\n      ? nextVals[0].length\n      : nextVals.length\n\n  // If filter size has not transitioned from single to multiple (or vice versa)\n  // or is unchanged, return the current operator.\n  if (a === b || (a >= 2 && b >= 2) || (a <= 1 && b <= 1))\n    return currentOperator\n\n  const opDetails = filterTypeOperatorDetails[type][currentOperator]\n\n  // Handle transition from single to multiple filter values.\n  if (a < b && b >= 2) return opDetails.singularOf ?? currentOperator\n  // Handle transition from multiple to single filter values.\n  if (a > b && b <= 1) return opDetails.pluralOf ?? currentOperator\n  return currentOperator\n}\n\n/**********************************************************************************************************\n ***** Filter Functions ******\n **********************************************************************************************************\n * These are functions that filter data based on the current filter values, column data type, and operator.\n * There exists a separate filter function for each column data type.\n *\n * Two variants of the filter functions are provided - as an example, we will take the optionFilterFn:\n * 1. optionFilterFn: takes in a row, columnId, and filterValue.\n * 2. __optionFilterFn: takes in an inputData and filterValue.\n *\n * __optionFilterFn is a private function that is used by filterFn to perform the actual filtering.\n * *********************************************************************************************************/\n\n/*\n * Returns a filter function for a given column data type.\n * This function is used to determine the appropriate filter function to use based on the column data type.\n */\nexport function filterFn(dataType: ColumnDataType) {\n  switch (dataType) {\n    case 'option':\n      return optionFilterFn\n    case 'multiOption':\n      return multiOptionFilterFn\n    case 'date':\n      return dateFilterFn\n    case 'text':\n      return textFilterFn\n    case 'number':\n      return numberFilterFn\n    default:\n      throw new Error('Invalid column data type')\n  }\n}\n\nexport function optionFilterFn<TData>(\n  row: Row<TData>,\n  columnId: string,\n  filterValue: FilterValue<'option', TData>,\n) {\n  const value = row.getValue(columnId)\n\n  if (!value) return false\n\n  const columnMeta = filterValue.column.columnDef.meta!\n\n  if (typeof value === 'string') {\n    return __optionFilterFn(value, filterValue)\n  }\n\n  if (isColumnOption(value)) {\n    return __optionFilterFn(value.value, filterValue)\n  }\n\n  const sanitizedValue = columnMeta.transformOptionFn!(value as never)\n  return __optionFilterFn(sanitizedValue.value, filterValue)\n}\n\nexport function __optionFilterFn<TData>(\n  inputData: string,\n  filterValue: FilterValue<'option', TData>,\n) {\n  if (!inputData) return false\n  if (filterValue.values.length === 0) return true\n\n  const value = inputData.toString().toLowerCase()\n\n  const found = !!filterValue.values.find((v) => v.toLowerCase() === value)\n\n  switch (filterValue.operator) {\n    case 'is':\n    case 'is any of':\n      return found\n    case 'is not':\n    case 'is none of':\n      return !found\n  }\n}\n\nfunction isColumnOption(value: unknown): value is ColumnOption {\n  return typeof value === 'object' && value !== null && 'value' in value\n}\n\nfunction isColumnOptionArray(value: unknown): value is ColumnOption[] {\n  return Array.isArray(value) && value.every(isColumnOption)\n}\n\nfunction isStringArray(value: unknown): value is string[] {\n  return Array.isArray(value) && value.every((v) => typeof v === 'string')\n}\n\nexport function multiOptionFilterFn<TData>(\n  row: Row<TData>,\n  columnId: string,\n  filterValue: FilterValue<'multiOption', TData>,\n) {\n  const value = row.getValue(columnId)\n\n  if (!value) return false\n\n  const columnMeta = filterValue.column.columnDef.meta!\n\n  if (isStringArray(value)) {\n    return __multiOptionFilterFn(value, filterValue)\n  }\n\n  if (isColumnOptionArray(value)) {\n    return __multiOptionFilterFn(\n      value.map((v) => v.value),\n      filterValue,\n    )\n  }\n\n  const sanitizedValue = (value as never[]).map((v) =>\n    columnMeta.transformOptionFn!(v),\n  )\n\n  return __multiOptionFilterFn(\n    sanitizedValue.map((v) => v.value),\n    filterValue,\n  )\n}\n\nexport function __multiOptionFilterFn<TData>(\n  inputData: string[],\n  filterValue: FilterValue<'multiOption', TData>,\n) {\n  if (!inputData) return false\n\n  if (\n    filterValue.values.length === 0 ||\n    !filterValue.values[0] ||\n    filterValue.values[0].length === 0\n  )\n    return true\n\n  const values = uniq(inputData)\n  const filterValues = uniq(filterValue.values[0])\n\n  // console.log('column values:', values)\n  // console.log('filter values:', filterValues)\n\n  switch (filterValue.operator) {\n    case 'include':\n    case 'include any of':\n      return intersection(values, filterValues).length > 0\n    case 'exclude':\n      return intersection(values, filterValues).length === 0\n    case 'exclude if any of':\n      return !(intersection(values, filterValues).length > 0)\n    case 'include all of':\n      return intersection(values, filterValues).length === filterValues.length\n    case 'exclude if all':\n      return !(\n        intersection(values, filterValues).length === filterValues.length\n      )\n  }\n}\n\nexport function dateFilterFn<TData>(\n  row: Row<TData>,\n  columnId: string,\n  filterValue: FilterValue<'date', TData>,\n) {\n  const valueStr = row.getValue<Date>(columnId)\n\n  return __dateFilterFn(valueStr, filterValue)\n}\n\nexport function __dateFilterFn<TData>(\n  inputData: Date,\n  filterValue: FilterValue<'date', TData>,\n) {\n  if (!filterValue || filterValue.values.length === 0) return true\n\n  if (\n    dateFilterDetails[filterValue.operator].target === 'single' &&\n    filterValue.values.length > 1\n  )\n    throw new Error('Singular operators require at most one filter value')\n\n  if (\n    filterValue.operator in ['is between', 'is not between'] &&\n    filterValue.values.length !== 2\n  )\n    throw new Error('Plural operators require two filter values')\n\n  const filterVals = filterValue.values\n  const d1 = filterVals[0]\n  const d2 = filterVals[1]\n\n  const value = inputData\n\n  switch (filterValue.operator) {\n    case 'is':\n      return isSameDay(value, d1)\n    case 'is not':\n      return !isSameDay(value, d1)\n    case 'is before':\n      return isBefore(value, startOfDay(d1))\n    case 'is on or after':\n      return isSameDay(value, d1) || isAfter(value, startOfDay(d1))\n    case 'is after':\n      return isAfter(value, startOfDay(d1))\n    case 'is on or before':\n      return isSameDay(value, d1) || isBefore(value, startOfDay(d1))\n    case 'is between':\n      return isWithinInterval(value, {\n        start: startOfDay(d1),\n        end: endOfDay(d2),\n      })\n    case 'is not between':\n      return !isWithinInterval(value, {\n        start: startOfDay(filterValue.values[0]),\n        end: endOfDay(filterValue.values[1]),\n      })\n  }\n}\n\nexport function textFilterFn<TData>(\n  row: Row<TData>,\n  columnId: string,\n  filterValue: FilterValue<'text', TData>,\n) {\n  const value = row.getValue<string>(columnId) ?? ''\n\n  return __textFilterFn(value, filterValue)\n}\n\nexport function __textFilterFn<TData>(\n  inputData: string,\n  filterValue: FilterValue<'text', TData>,\n) {\n  if (!filterValue || filterValue.values.length === 0) return true\n\n  const value = inputData.toLowerCase().trim()\n  const filterStr = filterValue.values[0].toLowerCase().trim()\n\n  if (filterStr === '') return true\n\n  const found = value.includes(filterStr)\n\n  switch (filterValue.operator) {\n    case 'contains':\n      return found\n    case 'does not contain':\n      return !found\n  }\n}\n\nexport function numberFilterFn<TData>(\n  row: Row<TData>,\n  columnId: string,\n  filterValue: FilterValue<'number', TData>,\n) {\n  const value = row.getValue<number>(columnId)\n\n  return __numberFilterFn(value, filterValue)\n}\n\nexport function __numberFilterFn<TData>(\n  inputData: number,\n  filterValue: FilterValue<'number', TData>,\n) {\n  if (!filterValue || !filterValue.values || filterValue.values.length === 0) {\n    return true\n  }\n\n  const value = inputData\n  const filterVal = filterValue.values[0]\n\n  switch (filterValue.operator) {\n    case 'is':\n      return value === filterVal\n    case 'is not':\n      return value !== filterVal\n    case 'is greater than':\n      return value > filterVal\n    case 'is greater than or equal to':\n      return value >= filterVal\n    case 'is less than':\n      return value < filterVal\n    case 'is less than or equal to':\n      return value <= filterVal\n    case 'is between': {\n      const lowerBound = filterValue.values[0]\n      const upperBound = filterValue.values[1]\n      return value >= lowerBound && value <= upperBound\n    }\n    case 'is not between': {\n      const lowerBound = filterValue.values[0]\n      const upperBound = filterValue.values[1]\n      return value < lowerBound || value > upperBound\n    }\n    default:\n      return true\n  }\n}\n\nexport function createNumberRange(values: number[] | undefined) {\n  let a = 0\n  let b = 0\n\n  if (!values || values.length === 0) return [a, b]\n  if (values.length === 1) {\n    a = values[0]\n  } else {\n    a = values[0]\n    b = values[1]\n  }\n\n  const [min, max] = a < b ? [a, b] : [b, a]\n\n  return [min, max]\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/data-table-filter/lib/table.ts",
      "content": "import type { Table } from '@tanstack/react-table'\n\nexport function getColumn<TData>(table: Table<TData>, id: string) {\n  const column = table.getColumn(id)\n\n  if (!column) {\n    throw new Error(`Column with id ${id} not found`)\n  }\n\n  return column\n}\n\nexport function getColumnMeta<TData>(table: Table<TData>, id: string) {\n  const column = getColumn(table, id)\n\n  if (!column.columnDef.meta) {\n    throw new Error(`Column meta not found for column ${id}`)\n  }\n\n  return column.columnDef.meta\n}\n",
      "type": "registry:lib"
    }
  ]
}