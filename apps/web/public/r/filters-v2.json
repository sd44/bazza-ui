{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "filters-v2",
  "type": "registry:block",
  "title": "Data table filter",
  "author": "Kian Bazarjani <kian@bazza.dev>",
  "description": "A powerful data table filter component inspired by Linear.",
  "dependencies": ["@tanstack/react-table@8.21.2", "date-fns"],
  "registryDependencies": [
    "button",
    "calendar",
    "checkbox",
    "command",
    "dropdown-menu",
    "input",
    "label",
    "popover",
    "separator",
    "slider",
    "table",
    "tabs",
    "use-mobile"
  ],
  "files": [
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/index.tsx",
      "content": "export { useDataTableFilters } from './hooks/use-data-table-filters'\r\nexport { DataTableFilter } from './components/data-table-filter'\r\n",
=======
      "path": "registry/data-table-filter/index.tsx",
      "content": "export { useDataTableFilters } from './hooks/use-data-table-filters'\nexport { DataTableFilter } from './components/data-table-filter'\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/index.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/components/active-filters.tsx",
      "content": "import { Button } from '@/components/ui/button'\r\nimport { Separator } from '@/components/ui/separator'\r\nimport { X } from 'lucide-react'\r\nimport { useEffect, useRef, useState } from 'react'\r\nimport type {\r\n  Column,\r\n  ColumnDataType,\r\n  DataTableFilterActions,\r\n  FilterModel,\r\n  FilterStrategy,\r\n  FiltersState,\r\n} from '../core/types'\r\nimport { getColumn } from '../lib/helpers'\r\nimport { FilterOperator } from './filter-operator'\r\nimport { FilterSubject } from './filter-subject'\r\nimport { FilterValue } from './filter-value'\r\nimport { Locale } from '../lib/i18n'\r\n\r\ninterface ActiveFiltersProps<TData> {\r\n  columns: Column<TData>[]\r\n  filters: FiltersState\r\n  actions: DataTableFilterActions\r\n  strategy: FilterStrategy\r\n  locale: Locale\r\n}\r\n\r\nexport function ActiveFilters<TData>({\r\n  columns,\r\n  filters,\r\n  actions,\r\n  strategy,\r\n  locale,\r\n}: ActiveFiltersProps<TData>) {\r\n  return (\r\n    <>\r\n      {filters.map((filter) => {\r\n        const id = filter.columnId\r\n\r\n        const column = getColumn(columns, id)\r\n\r\n        // Skip if no filter value\r\n        if (!filter.values) return null\r\n\r\n        return (\r\n          <ActiveFilter\r\n            key={`active-filter-${filter.columnId}`}\r\n            filter={filter}\r\n            column={column}\r\n            actions={actions}\r\n            strategy={strategy}\r\n            locale={locale}\r\n          />\r\n        )\r\n      })}\r\n    </>\r\n  )\r\n}\r\n\r\ninterface ActiveFilterProps<TData, TType extends ColumnDataType> {\r\n  filter: FilterModel<TType>\r\n  column: Column<TData, TType>\r\n  actions: DataTableFilterActions\r\n  strategy: FilterStrategy\r\n  locale: Locale\r\n}\r\n\r\n// Generic render function for a filter with type-safe value\r\nexport function ActiveFilter<TData, TType extends ColumnDataType>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  strategy,\r\n  locale,\r\n}: ActiveFilterProps<TData, TType>) {\r\n  return (\r\n    <div className=\"flex h-7 items-center rounded-2xl border border-border bg-background shadow-xs text-xs\">\r\n      <FilterSubject column={column} />\r\n      <Separator orientation=\"vertical\" />\r\n      <FilterOperator filter={filter} column={column} actions={actions} locale={locale} />\r\n      <Separator orientation=\"vertical\" />\r\n      <FilterValue\r\n        filter={filter}\r\n        column={column}\r\n        actions={actions}\r\n        strategy={strategy}\r\n        locale={locale}\r\n      />\r\n      <Separator orientation=\"vertical\" />\r\n      <Button\r\n        variant=\"ghost\"\r\n        className=\"rounded-none rounded-r-2xl text-xs w-7 h-full\"\r\n        onClick={() => actions.removeFilter(filter.columnId)}\r\n      >\r\n        <X className=\"size-4 -translate-x-0.5\" />\r\n      </Button>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport function ActiveFiltersMobileContainer({\r\n  children,\r\n}: { children: React.ReactNode }) {\r\n  const scrollContainerRef = useRef<HTMLDivElement>(null)\r\n  const [showLeftBlur, setShowLeftBlur] = useState(false)\r\n  const [showRightBlur, setShowRightBlur] = useState(true)\r\n\r\n  // Check if there's content to scroll and update blur states\r\n  const checkScroll = () => {\r\n    if (scrollContainerRef.current) {\r\n      const { scrollLeft, scrollWidth, clientWidth } =\r\n        scrollContainerRef.current\r\n\r\n      // Show left blur if scrolled to the right\r\n      setShowLeftBlur(scrollLeft > 0)\r\n\r\n      // Show right blur if there's more content to scroll to the right\r\n      // Add a small buffer (1px) to account for rounding errors\r\n      setShowRightBlur(scrollLeft + clientWidth < scrollWidth - 1)\r\n    }\r\n  }\r\n\r\n  // Log blur states for debugging\r\n  // useEffect(() => {\r\n  //   console.log('left:', showLeftBlur, '  right:', showRightBlur)\r\n  // }, [showLeftBlur, showRightBlur])\r\n\r\n  // Set up ResizeObserver to monitor container size\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\r\n  useEffect(() => {\r\n    if (scrollContainerRef.current) {\r\n      const resizeObserver = new ResizeObserver(() => {\r\n        checkScroll()\r\n      })\r\n      resizeObserver.observe(scrollContainerRef.current)\r\n      return () => {\r\n        resizeObserver.disconnect()\r\n      }\r\n    }\r\n  }, [])\r\n\r\n  // Update blur states when children change\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\r\n  useEffect(() => {\r\n    checkScroll()\r\n  }, [children])\r\n\r\n  return (\r\n    <div className=\"relative w-full overflow-x-hidden\">\r\n      {/* Left blur effect */}\r\n      {showLeftBlur && (\r\n        <div className=\"absolute left-0 top-0 bottom-0 w-16 z-10 pointer-events-none bg-gradient-to-r from-background to-transparent animate-in fade-in-0\" />\r\n      )}\r\n\r\n      {/* Scrollable container */}\r\n      <div\r\n        ref={scrollContainerRef}\r\n        className=\"flex gap-2 overflow-x-scroll no-scrollbar\"\r\n        onScroll={checkScroll}\r\n      >\r\n        {children}\r\n      </div>\r\n\r\n      {/* Right blur effect */}\r\n      {showRightBlur && (\r\n        <div className=\"absolute right-0 top-0 bottom-0 w-16 z-10 pointer-events-none bg-gradient-to-l from-background to-transparent animate-in fade-in-0 \" />\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n",
=======
      "path": "registry/data-table-filter/components/active-filters.tsx",
      "content": "import { Button } from '@/components/ui/button'\nimport { Separator } from '@/components/ui/separator'\nimport { X } from 'lucide-react'\nimport { useEffect, useRef, useState } from 'react'\nimport type {\n  Column,\n  ColumnDataType,\n  DataTableFilterActions,\n  FilterModel,\n  FilterStrategy,\n  FiltersState,\n} from '../core/types'\nimport { getColumn } from '../lib/helpers'\nimport { FilterOperator } from './filter-operator'\nimport { FilterSubject } from './filter-subject'\nimport { FilterValue } from './filter-value'\n\ninterface ActiveFiltersProps<TData> {\n  columns: Column<TData>[]\n  filters: FiltersState\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n}\n\nexport function ActiveFilters<TData>({\n  columns,\n  filters,\n  actions,\n  strategy,\n}: ActiveFiltersProps<TData>) {\n  return (\n    <>\n      {filters.map((filter) => {\n        const id = filter.columnId\n\n        const column = getColumn(columns, id)\n\n        // Skip if no filter value\n        if (!filter.values) return null\n\n        return (\n          <ActiveFilter\n            key={`active-filter-${filter.columnId}`}\n            filter={filter}\n            column={column}\n            actions={actions}\n            strategy={strategy}\n          />\n        )\n      })}\n    </>\n  )\n}\n\ninterface ActiveFilterProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n}\n\n// Generic render function for a filter with type-safe value\nexport function ActiveFilter<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  strategy,\n}: ActiveFilterProps<TData, TType>) {\n  return (\n    <div className=\"flex h-7 items-center rounded-2xl border border-border bg-background shadow-xs text-xs\">\n      <FilterSubject column={column} />\n      <Separator orientation=\"vertical\" />\n      <FilterOperator filter={filter} column={column} actions={actions} />\n      <Separator orientation=\"vertical\" />\n      <FilterValue\n        filter={filter}\n        column={column}\n        actions={actions}\n        strategy={strategy}\n      />\n      <Separator orientation=\"vertical\" />\n      <Button\n        variant=\"ghost\"\n        className=\"rounded-none rounded-r-2xl text-xs w-7 h-full\"\n        onClick={() => actions.removeFilter(filter.columnId)}\n      >\n        <X className=\"size-4 -translate-x-0.5\" />\n      </Button>\n    </div>\n  )\n}\n\nexport function ActiveFiltersMobileContainer({\n  children,\n}: { children: React.ReactNode }) {\n  const scrollContainerRef = useRef<HTMLDivElement>(null)\n  const [showLeftBlur, setShowLeftBlur] = useState(false)\n  const [showRightBlur, setShowRightBlur] = useState(true)\n\n  // Check if there's content to scroll and update blur states\n  const checkScroll = () => {\n    if (scrollContainerRef.current) {\n      const { scrollLeft, scrollWidth, clientWidth } =\n        scrollContainerRef.current\n\n      // Show left blur if scrolled to the right\n      setShowLeftBlur(scrollLeft > 0)\n\n      // Show right blur if there's more content to scroll to the right\n      // Add a small buffer (1px) to account for rounding errors\n      setShowRightBlur(scrollLeft + clientWidth < scrollWidth - 1)\n    }\n  }\n\n  // Log blur states for debugging\n  // useEffect(() => {\n  //   console.log('left:', showLeftBlur, '  right:', showRightBlur)\n  // }, [showLeftBlur, showRightBlur])\n\n  // Set up ResizeObserver to monitor container size\n  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n  useEffect(() => {\n    if (scrollContainerRef.current) {\n      const resizeObserver = new ResizeObserver(() => {\n        checkScroll()\n      })\n      resizeObserver.observe(scrollContainerRef.current)\n      return () => {\n        resizeObserver.disconnect()\n      }\n    }\n  }, [])\n\n  // Update blur states when children change\n  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n  useEffect(() => {\n    checkScroll()\n  }, [children])\n\n  return (\n    <div className=\"relative w-full overflow-x-hidden\">\n      {/* Left blur effect */}\n      {showLeftBlur && (\n        <div className=\"absolute left-0 top-0 bottom-0 w-16 z-10 pointer-events-none bg-gradient-to-r from-background to-transparent animate-in fade-in-0\" />\n      )}\n\n      {/* Scrollable container */}\n      <div\n        ref={scrollContainerRef}\n        className=\"flex gap-2 overflow-x-scroll no-scrollbar\"\n        onScroll={checkScroll}\n      >\n        {children}\n      </div>\n\n      {/* Right blur effect */}\n      {showRightBlur && (\n        <div className=\"absolute right-0 top-0 bottom-0 w-16 z-10 pointer-events-none bg-gradient-to-l from-background to-transparent animate-in fade-in-0 \" />\n      )}\n    </div>\n  )\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/components/active-filters.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/components/data-table-filter.tsx",
      "content": "'use client'\r\n\r\nimport { useIsMobile } from '@/hooks/use-mobile'\r\nimport type {\r\n  Column,\r\n  DataTableFilterActions,\r\n  FilterStrategy,\r\n  FiltersState,\r\n} from '../core/types'\r\nimport { ActiveFilters, ActiveFiltersMobileContainer } from './active-filters'\r\nimport { FilterActions } from './filter-actions'\r\nimport { FilterSelector } from './filter-selector'\r\nimport { Locale } from '../lib/i18n'\r\n\r\ninterface DataTableFilterProps<TData> {\r\n  columns: Column<TData>[]\r\n  filters: FiltersState\r\n  actions: DataTableFilterActions\r\n  strategy: FilterStrategy\r\n  locale?: Locale\r\n}\r\n\r\nexport function DataTableFilter<TData>({\r\n  columns,\r\n  filters,\r\n  actions,\r\n  strategy,\r\n  locale = 'en',\r\n}: DataTableFilterProps<TData>) {\r\n  const isMobile = useIsMobile()\r\n  if (isMobile) {\r\n    return (\r\n      <div className=\"flex w-full items-start justify-between gap-2\">\r\n        <div className=\"flex gap-1\">\r\n          <FilterSelector\r\n            columns={columns}\r\n            filters={filters}\r\n            actions={actions}\r\n            strategy={strategy}\r\n            locale={locale}\r\n          />\r\n          <FilterActions hasFilters={filters.length > 0} actions={actions} locale={locale} />\r\n        </div>\r\n        <ActiveFiltersMobileContainer>\r\n          <ActiveFilters\r\n            columns={columns}\r\n            filters={filters}\r\n            actions={actions}\r\n            strategy={strategy}\r\n            locale={locale}\r\n          />\r\n        </ActiveFiltersMobileContainer>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex w-full items-start justify-between gap-2\">\r\n      <div className=\"flex md:flex-wrap gap-2 w-full flex-1\">\r\n        <FilterSelector\r\n          columns={columns}\r\n          filters={filters}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n        <ActiveFilters\r\n          columns={columns}\r\n          filters={filters}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n      </div>\r\n      <FilterActions hasFilters={filters.length > 0} actions={actions} locale={locale} />\r\n    </div>\r\n  )\r\n}\r\n",
=======
      "path": "registry/data-table-filter/components/data-table-filter.tsx",
      "content": "'use client'\n\nimport { useIsMobile } from '@/hooks/use-mobile'\nimport type {\n  Column,\n  DataTableFilterActions,\n  FilterStrategy,\n  FiltersState,\n} from '../core/types'\nimport { ActiveFilters, ActiveFiltersMobileContainer } from './active-filters'\nimport { FilterActions } from './filter-actions'\nimport { FilterSelector } from './filter-selector'\n\ninterface DataTableFilterProps<TData> {\n  columns: Column<TData>[]\n  filters: FiltersState\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n}\n\nexport function DataTableFilter<TData>({\n  columns,\n  filters,\n  actions,\n  strategy,\n}: DataTableFilterProps<TData>) {\n  const isMobile = useIsMobile()\n  if (isMobile) {\n    return (\n      <div className=\"flex w-full items-start justify-between gap-2\">\n        <div className=\"flex gap-1\">\n          <FilterSelector\n            columns={columns}\n            filters={filters}\n            actions={actions}\n            strategy={strategy}\n          />\n          <FilterActions hasFilters={filters.length > 0} actions={actions} />\n        </div>\n        <ActiveFiltersMobileContainer>\n          <ActiveFilters\n            columns={columns}\n            filters={filters}\n            actions={actions}\n            strategy={strategy}\n          />\n        </ActiveFiltersMobileContainer>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex w-full items-start justify-between gap-2\">\n      <div className=\"flex md:flex-wrap gap-2 w-full flex-1\">\n        <FilterSelector\n          columns={columns}\n          filters={filters}\n          actions={actions}\n          strategy={strategy}\n        />\n        <ActiveFilters\n          columns={columns}\n          filters={filters}\n          actions={actions}\n          strategy={strategy}\n        />\n      </div>\n      <FilterActions hasFilters={filters.length > 0} actions={actions} />\n    </div>\n  )\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/components/data-table-filter.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/components/filter-actions.tsx",
      "content": "import { Button } from '@/components/ui/button'\r\nimport { cn } from '@/lib/utils'\r\nimport { FilterXIcon } from 'lucide-react'\r\nimport { memo } from 'react'\r\nimport type { DataTableFilterActions } from '../core/types'\r\nimport { Locale, t } from '../lib/i18n'\r\n\r\ninterface FilterActionsProps {\r\n  hasFilters: boolean\r\n  actions?: DataTableFilterActions\r\n  locale: Locale\r\n}\r\n\r\nexport const FilterActions = memo(__FilterActions)\r\nfunction __FilterActions({ hasFilters, actions, locale }: FilterActionsProps) {\r\n  return (\r\n    <Button\r\n      className={cn('h-7 !px-2', !hasFilters && 'hidden')}\r\n      variant=\"destructive\"\r\n      onClick={actions?.removeAllFilters}\r\n    >\r\n      <FilterXIcon />\r\n      <span className=\"hidden md:block\">{t(\"clear\", locale)}</span>\r\n    </Button>\r\n  )\r\n}\r\n",
=======
      "path": "registry/data-table-filter/components/filter-actions.tsx",
      "content": "import { Button } from '@/components/ui/button'\nimport { cn } from '@/lib/utils'\nimport { FilterXIcon } from 'lucide-react'\nimport { memo } from 'react'\nimport type { DataTableFilterActions } from '../core/types'\n\ninterface FilterActionsProps {\n  hasFilters: boolean\n  actions?: DataTableFilterActions\n}\n\nexport const FilterActions = memo(__FilterActions)\nfunction __FilterActions({ hasFilters, actions }: FilterActionsProps) {\n  return (\n    <Button\n      className={cn('h-7 !px-2', !hasFilters && 'hidden')}\n      variant=\"destructive\"\n      onClick={actions?.removeAllFilters}\n    >\n      <FilterXIcon />\n      <span className=\"hidden md:block\">Clear</span>\n    </Button>\n  )\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-actions.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/components/filter-operator.tsx",
      "content": "import { Button } from '@/components/ui/button'\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from '@/components/ui/command'\r\nimport {\r\n  Popover,\r\n  PopoverAnchor,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/components/ui/popover'\r\nimport { useState } from 'react'\r\nimport {\r\n  getDateFilterDetails,\r\n  getFilterTypeOperatorDetails,\r\n  getMultiOptionFilterDetails,\r\n  getNumberFilterDetails,\r\n  getOptionFilterDetails,\r\n  getTextFilterDetails,\r\n} from '../core/operators'\r\nimport type {\r\n  Column,\r\n  ColumnDataType,\r\n  DataTableFilterActions,\r\n  FilterModel,\r\n  FilterOperators,\r\n  FilterStrategy,\r\n} from '../core/types'\r\nimport { Locale, t } from '../lib/i18n'\r\n\r\ninterface FilterOperatorProps<TData, TType extends ColumnDataType> {\r\n  column: Column<TData, TType>\r\n  filter: FilterModel<TType>\r\n  actions: DataTableFilterActions\r\n  locale: Locale\r\n}\r\n\r\n// Renders the filter operator display and menu for a given column filter\r\n// The filter operator display is the label and icon for the filter operator\r\n// The filter operator menu is the dropdown menu for the filter operator\r\nexport function FilterOperator<TData, TType extends ColumnDataType>({\r\n  column,\r\n  filter,\r\n  actions,\r\n  locale,\r\n}: FilterOperatorProps<TData, TType>) {\r\n  const [open, setOpen] = useState<boolean>(false)\r\n\r\n  const close = () => setOpen(false)\r\n\r\n  return (\r\n    <Popover open={open} onOpenChange={setOpen}>\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          variant=\"ghost\"\r\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\r\n        >\r\n          <FilterOperatorDisplay filter={filter} columnType={column.type} locale={locale} />\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent\r\n        align=\"start\"\r\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\r\n      >\r\n        <Command loop>\r\n          <CommandInput placeholder={t(\"search\", locale)} />\r\n          <CommandEmpty>{t(\"noresults\", locale)}</CommandEmpty>\r\n          <CommandList className=\"max-h-fit\">\r\n            <FilterOperatorController\r\n              filter={filter}\r\n              column={column}\r\n              actions={actions}\r\n              closeController={close}\r\n              locale={locale}\r\n            />\r\n          </CommandList>\r\n        </Command>\r\n      </PopoverContent>\r\n    </Popover>\r\n  )\r\n}\r\n\r\ninterface FilterOperatorDisplayProps<TType extends ColumnDataType> {\r\n  filter: FilterModel<TType>\r\n  columnType: TType\r\n  locale: Locale\r\n}\r\n\r\nexport function FilterOperatorDisplay<TType extends ColumnDataType>({\r\n  filter,\r\n  columnType,\r\n  locale,\r\n}: FilterOperatorDisplayProps<TType>) {\r\n  const operator = getFilterTypeOperatorDetails(locale)[columnType][filter.operator]\r\n\r\n  return <span className=\"text-muted-foreground\">{operator.label}</span>\r\n}\r\n\r\ninterface FilterOperatorControllerProps<TData, TType extends ColumnDataType> {\r\n  filter: FilterModel<TType>\r\n  column: Column<TData, TType>\r\n  actions: DataTableFilterActions\r\n  closeController: () => void\r\n  locale: Locale\r\n}\r\n\r\n/*\r\n *\r\n * TODO: Reduce into a single component. Each data type does not need it's own controller.\r\n *\r\n */\r\nexport function FilterOperatorController<TData, TType extends ColumnDataType>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  closeController,\r\n  locale,\r\n}: FilterOperatorControllerProps<TData, TType>) {\r\n  switch (column.type) {\r\n    case 'option':\r\n      return (\r\n        <FilterOperatorOptionController\r\n          filter={filter as FilterModel<'option'>}\r\n          column={column as Column<TData, 'option'>}\r\n          actions={actions}\r\n          closeController={closeController}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'multiOption':\r\n      return (\r\n        <FilterOperatorMultiOptionController\r\n          filter={filter as FilterModel<'multiOption'>}\r\n          column={column as Column<TData, 'multiOption'>}\r\n          actions={actions}\r\n          closeController={closeController}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'date':\r\n      return (\r\n        <FilterOperatorDateController\r\n          filter={filter as FilterModel<'date'>}\r\n          column={column as Column<TData, 'date'>}\r\n          actions={actions}\r\n          closeController={closeController}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'text':\r\n      return (\r\n        <FilterOperatorTextController\r\n          filter={filter as FilterModel<'text'>}\r\n          column={column as Column<TData, 'text'>}\r\n          actions={actions}\r\n          closeController={closeController}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'number':\r\n      return (\r\n        <FilterOperatorNumberController\r\n          filter={filter as FilterModel<'number'>}\r\n          column={column as Column<TData, 'number'>}\r\n          actions={actions}\r\n          closeController={closeController}\r\n          locale={locale}\r\n        />\r\n      )\r\n    default:\r\n      return null\r\n  }\r\n}\r\n\r\nfunction FilterOperatorOptionController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  closeController,\r\n  locale,\r\n}: FilterOperatorControllerProps<TData, 'option'>) {\r\n  const filterDetails = getOptionFilterDetails(locale)[filter.operator]\r\n\r\n  const relatedFilters = Object.values(getOptionFilterDetails(locale)).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    actions?.setFilterOperator(column.id, value as FilterOperators['option'])\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <CommandGroup heading={t(\"operators\", locale)}>\r\n      {relatedFilters.map((r) => {\r\n        return (\r\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\r\n            {r.label}\r\n          </CommandItem>\r\n        )\r\n      })}\r\n    </CommandGroup>\r\n  )\r\n}\r\n\r\nfunction FilterOperatorMultiOptionController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  closeController,\r\n  locale,\r\n}: FilterOperatorControllerProps<TData, 'multiOption'>) {\r\n  const filterDetails = getMultiOptionFilterDetails(locale)[filter.operator]\r\n\r\n  const relatedFilters = Object.values(getMultiOptionFilterDetails(locale)).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    actions?.setFilterOperator(\r\n      column.id,\r\n      value as FilterOperators['multiOption'],\r\n    )\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <CommandGroup heading={t(\"operators\", locale)}>\r\n      {relatedFilters.map((r) => {\r\n        return (\r\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\r\n            {r.label}\r\n          </CommandItem>\r\n        )\r\n      })}\r\n    </CommandGroup>\r\n  )\r\n}\r\n\r\nfunction FilterOperatorDateController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  closeController,\r\n  locale,\r\n}: FilterOperatorControllerProps<TData, 'date'>) {\r\n  const filterDetails = getDateFilterDetails(locale)[filter.operator]\r\n\r\n  const relatedFilters = Object.values(getDateFilterDetails(locale)).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    actions?.setFilterOperator(column.id, value as FilterOperators['date'])\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <CommandGroup>\r\n      {relatedFilters.map((r) => {\r\n        return (\r\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\r\n            {r.label}\r\n          </CommandItem>\r\n        )\r\n      })}\r\n    </CommandGroup>\r\n  )\r\n}\r\n\r\nexport function FilterOperatorTextController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  closeController,\r\n  locale,\r\n}: FilterOperatorControllerProps<TData, 'text'>) {\r\n  const filterDetails = getTextFilterDetails(locale)[filter.operator]\r\n\r\n  const relatedFilters = Object.values(getTextFilterDetails(locale)).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    actions?.setFilterOperator(column.id, value as FilterOperators['text'])\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <CommandGroup heading={t(\"operators\", locale)}>\r\n      {relatedFilters.map((r) => {\r\n        return (\r\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\r\n            {r.label}\r\n          </CommandItem>\r\n        )\r\n      })}\r\n    </CommandGroup>\r\n  )\r\n}\r\n\r\nfunction FilterOperatorNumberController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  closeController,\r\n  locale,\r\n}: FilterOperatorControllerProps<TData, 'number'>) {\r\n  // Show all related operators\r\n  const filterDetails = getNumberFilterDetails(locale)[filter.operator]\r\n\r\n  const relatedFilters = Object.values(getNumberFilterDetails(locale)).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    actions?.setFilterOperator(column.id, value as FilterOperators['number'])\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <CommandGroup heading={t(\"operators\", locale)}>\r\n        {relatedFilters.map((r) => (\r\n          <CommandItem\r\n            onSelect={() => changeOperator(r.value)}\r\n            value={r.value}\r\n            key={r.value}\r\n          >\r\n            {r.label} {/**/}\r\n          </CommandItem>\r\n        ))}\r\n      </CommandGroup>\r\n    </div>\r\n  )\r\n}\r\n",
=======
      "path": "registry/data-table-filter/components/filter-operator.tsx",
      "content": "import { Button } from '@/components/ui/button'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport {\n  Popover,\n  PopoverAnchor,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport { useState } from 'react'\nimport {\n  dateFilterDetails,\n  filterTypeOperatorDetails,\n  multiOptionFilterDetails,\n  numberFilterDetails,\n  optionFilterDetails,\n  textFilterDetails,\n} from '../core/operators'\nimport type {\n  Column,\n  ColumnDataType,\n  DataTableFilterActions,\n  FilterModel,\n  FilterOperators,\n  FilterStrategy,\n} from '../core/types'\n\ninterface FilterOperatorProps<TData, TType extends ColumnDataType> {\n  column: Column<TData, TType>\n  filter: FilterModel<TType>\n  actions: DataTableFilterActions\n}\n\n// Renders the filter operator display and menu for a given column filter\n// The filter operator display is the label and icon for the filter operator\n// The filter operator menu is the dropdown menu for the filter operator\nexport function FilterOperator<TData, TType extends ColumnDataType>({\n  column,\n  filter,\n  actions,\n}: FilterOperatorProps<TData, TType>) {\n  const [open, setOpen] = useState<boolean>(false)\n\n  const close = () => setOpen(false)\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"ghost\"\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\n        >\n          <FilterOperatorDisplay filter={filter} columnType={column.type} />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        <Command loop>\n          <CommandInput placeholder=\"Search...\" />\n          <CommandEmpty>No results.</CommandEmpty>\n          <CommandList className=\"max-h-fit\">\n            <FilterOperatorController\n              filter={filter}\n              column={column}\n              actions={actions}\n              closeController={close}\n            />\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n\ninterface FilterOperatorDisplayProps<TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  columnType: TType\n}\n\nexport function FilterOperatorDisplay<TType extends ColumnDataType>({\n  filter,\n  columnType,\n}: FilterOperatorDisplayProps<TType>) {\n  const operator = filterTypeOperatorDetails[columnType][filter.operator]\n\n  return <span className=\"text-muted-foreground\">{operator.label}</span>\n}\n\ninterface FilterOperatorControllerProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  closeController: () => void\n}\n\n/*\n *\n * TODO: Reduce into a single component. Each data type does not need it's own controller.\n *\n */\nexport function FilterOperatorController<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  closeController,\n}: FilterOperatorControllerProps<TData, TType>) {\n  switch (column.type) {\n    case 'option':\n      return (\n        <FilterOperatorOptionController\n          filter={filter as FilterModel<'option'>}\n          column={column as Column<TData, 'option'>}\n          actions={actions}\n          closeController={closeController}\n        />\n      )\n    case 'multiOption':\n      return (\n        <FilterOperatorMultiOptionController\n          filter={filter as FilterModel<'multiOption'>}\n          column={column as Column<TData, 'multiOption'>}\n          actions={actions}\n          closeController={closeController}\n        />\n      )\n    case 'date':\n      return (\n        <FilterOperatorDateController\n          filter={filter as FilterModel<'date'>}\n          column={column as Column<TData, 'date'>}\n          actions={actions}\n          closeController={closeController}\n        />\n      )\n    case 'text':\n      return (\n        <FilterOperatorTextController\n          filter={filter as FilterModel<'text'>}\n          column={column as Column<TData, 'text'>}\n          actions={actions}\n          closeController={closeController}\n        />\n      )\n    case 'number':\n      return (\n        <FilterOperatorNumberController\n          filter={filter as FilterModel<'number'>}\n          column={column as Column<TData, 'number'>}\n          actions={actions}\n          closeController={closeController}\n        />\n      )\n    default:\n      return null\n  }\n}\n\nfunction FilterOperatorOptionController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n}: FilterOperatorControllerProps<TData, 'option'>) {\n  const filterDetails = optionFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(optionFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(column.id, value as FilterOperators['option'])\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading=\"Operators\">\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {r.label}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction FilterOperatorMultiOptionController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n}: FilterOperatorControllerProps<TData, 'multiOption'>) {\n  const filterDetails = multiOptionFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(multiOptionFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(\n      column.id,\n      value as FilterOperators['multiOption'],\n    )\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading=\"Operators\">\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {r.label}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction FilterOperatorDateController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n}: FilterOperatorControllerProps<TData, 'date'>) {\n  const filterDetails = dateFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(dateFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(column.id, value as FilterOperators['date'])\n    closeController()\n  }\n\n  return (\n    <CommandGroup>\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {r.label}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nexport function FilterOperatorTextController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n}: FilterOperatorControllerProps<TData, 'text'>) {\n  const filterDetails = textFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(textFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(column.id, value as FilterOperators['text'])\n    closeController()\n  }\n\n  return (\n    <CommandGroup heading=\"Operators\">\n      {relatedFilters.map((r) => {\n        return (\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\n            {r.label}\n          </CommandItem>\n        )\n      })}\n    </CommandGroup>\n  )\n}\n\nfunction FilterOperatorNumberController<TData>({\n  filter,\n  column,\n  actions,\n  closeController,\n}: FilterOperatorControllerProps<TData, 'number'>) {\n  // Show all related operators\n  const filterDetails = numberFilterDetails[filter.operator]\n\n  const relatedFilters = Object.values(numberFilterDetails).filter(\n    (o) => o.target === filterDetails.target,\n  )\n\n  const changeOperator = (value: string) => {\n    actions?.setFilterOperator(column.id, value as FilterOperators['number'])\n    closeController()\n  }\n\n  return (\n    <div>\n      <CommandGroup heading=\"Operators\">\n        {relatedFilters.map((r) => (\n          <CommandItem\n            onSelect={() => changeOperator(r.value)}\n            value={r.value}\n            key={r.value}\n          >\n            {r.label} {/**/}\n          </CommandItem>\n        ))}\n      </CommandGroup>\n    </div>\n  )\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-operator.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/components/filter-selector.tsx",
      "content": "import { Button } from '@/components/ui/button'\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from '@/components/ui/command'\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/components/ui/popover'\r\nimport { cn } from '@/lib/utils'\r\nimport { ArrowRightIcon, FilterIcon } from 'lucide-react'\r\nimport { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react'\r\nimport type {\r\n  Column,\r\n  ColumnDataType,\r\n  DataTableFilterActions,\r\n  FilterStrategy,\r\n  FiltersState,\r\n} from '../core/types'\r\nimport { getColumn } from '../lib/helpers'\r\nimport { FilterValueController } from './filter-value'\r\nimport { Locale, t } from '../lib/i18n'\r\n\r\ninterface FilterSelectorProps<TData> {\r\n  filters: FiltersState\r\n  columns: Column<TData>[]\r\n  actions: DataTableFilterActions\r\n  strategy: FilterStrategy\r\n  locale: Locale\r\n}\r\n\r\nexport const FilterSelector = memo(__FilterSelector) as typeof __FilterSelector\r\n\r\nfunction __FilterSelector<TData>({\r\n  filters,\r\n  columns,\r\n  actions,\r\n  strategy,\r\n  locale,\r\n}: FilterSelectorProps<TData>) {\r\n  const [open, setOpen] = useState(false)\r\n  const [value, setValue] = useState('')\r\n  const [property, setProperty] = useState<string | undefined>(undefined)\r\n  const inputRef = useRef<HTMLInputElement>(null)\r\n\r\n  const column = property ? getColumn(columns, property) : undefined\r\n  const filter = property\r\n    ? filters.find((f) => f.columnId === property)\r\n    : undefined\r\n\r\n  const hasFilters = filters.length > 0\r\n\r\n  useEffect(() => {\r\n    if (property && inputRef) {\r\n      inputRef.current?.focus()\r\n      setValue('')\r\n    }\r\n  }, [property])\r\n\r\n  useEffect(() => {\r\n    if (!open) setTimeout(() => setValue(''), 150)\r\n  }, [open])\r\n\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: need filters to be updated\r\n  const content = useMemo(\r\n    () =>\r\n      property && column ? (\r\n        <FilterValueController\r\n          filter={filter!}\r\n          column={column as Column<TData, ColumnDataType>}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n      ) : (\r\n        <Command loop>\r\n          <CommandInput\r\n            value={value}\r\n            onValueChange={setValue}\r\n            ref={inputRef}\r\n            placeholder={t('search', locale)}\r\n          />\r\n          <CommandEmpty>{t('noresults', locale)}</CommandEmpty>\r\n          <CommandList className=\"max-h-fit\">\r\n            <CommandGroup>\r\n              {columns.map((column) => (\r\n                <FilterableColumn\r\n                  key={column.id}\r\n                  column={column}\r\n                  setProperty={setProperty}\r\n                />\r\n              ))}\r\n            </CommandGroup>\r\n          </CommandList>\r\n        </Command>\r\n      ),\r\n    [property, column, filter, filters, columns, actions, value],\r\n  )\r\n\r\n  return (\r\n    <Popover\r\n      open={open}\r\n      onOpenChange={async (value) => {\r\n        setOpen(value)\r\n        if (!value) setTimeout(() => setProperty(undefined), 100)\r\n      }}\r\n    >\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          variant=\"outline\"\r\n          className={cn('h-7', hasFilters && 'w-fit !px-2')}\r\n        >\r\n          <FilterIcon className=\"size-4\" />\r\n          {!hasFilters && <span>{t('filter', locale)}</span>}\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent\r\n        align=\"start\"\r\n        side=\"bottom\"\r\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\r\n      >\r\n        {content}\r\n      </PopoverContent>\r\n    </Popover>\r\n  )\r\n}\r\n\r\nexport function FilterableColumn<TData, TType extends ColumnDataType, TVal>({\r\n  column,\r\n  setProperty,\r\n}: {\r\n  column: Column<TData, TType, TVal>\r\n  setProperty: (value: string) => void\r\n}) {\r\n  const itemRef = useRef<HTMLDivElement>(null)\r\n\r\n  const prefetch = useCallback(() => {\r\n    column.prefetchOptions()\r\n    column.prefetchValues()\r\n    column.prefetchFacetedUniqueValues()\r\n  }, [column])\r\n\r\n  useEffect(() => {\r\n    const target = itemRef.current\r\n\r\n    if (!target) return\r\n\r\n    // Set up MutationObserver\r\n    const observer = new MutationObserver((mutations) => {\r\n      for (const mutation of mutations) {\r\n        if (mutation.type === 'attributes') {\r\n          const isSelected = target.getAttribute('data-selected') === 'true'\r\n          if (isSelected) prefetch()\r\n        }\r\n      }\r\n    })\r\n\r\n    // Set up observer\r\n    observer.observe(target, {\r\n      attributes: true,\r\n      attributeFilter: ['data-selected'],\r\n    })\r\n\r\n    // Cleanup on unmount\r\n    return () => observer.disconnect()\r\n  }, [prefetch])\r\n\r\n  return (\r\n    <CommandItem\r\n      ref={itemRef}\r\n      onSelect={() => setProperty(column.id)}\r\n      className=\"group\"\r\n      onMouseEnter={prefetch}\r\n    >\r\n      <div className=\"flex w-full items-center justify-between\">\r\n        <div className=\"inline-flex items-center gap-1.5\">\r\n          {<column.icon strokeWidth={2.25} className=\"size-4\" />}\r\n          <span>{column.displayName}</span>\r\n        </div>\r\n        <ArrowRightIcon className=\"size-4 opacity-0 group-aria-selected:opacity-100\" />\r\n      </div>\r\n    </CommandItem>\r\n  )\r\n}\r\n",
=======
      "path": "registry/data-table-filter/components/filter-selector.tsx",
      "content": "import { Button } from '@/components/ui/button'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport { cn } from '@/lib/utils'\nimport { ArrowRightIcon, FilterIcon } from 'lucide-react'\nimport { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport type {\n  Column,\n  ColumnDataType,\n  DataTableFilterActions,\n  FilterStrategy,\n  FiltersState,\n} from '../core/types'\nimport { getColumn } from '../lib/helpers'\nimport { FilterValueController } from './filter-value'\n\ninterface FilterSelectorProps<TData> {\n  filters: FiltersState\n  columns: Column<TData>[]\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n}\n\nexport const FilterSelector = memo(__FilterSelector) as typeof __FilterSelector\n\nfunction __FilterSelector<TData>({\n  filters,\n  columns,\n  actions,\n  strategy,\n}: FilterSelectorProps<TData>) {\n  const [open, setOpen] = useState(false)\n  const [value, setValue] = useState('')\n  const [property, setProperty] = useState<string | undefined>(undefined)\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  const column = property ? getColumn(columns, property) : undefined\n  const filter = property\n    ? filters.find((f) => f.columnId === property)\n    : undefined\n\n  const hasFilters = filters.length > 0\n\n  useEffect(() => {\n    if (property && inputRef) {\n      inputRef.current?.focus()\n      setValue('')\n    }\n  }, [property])\n\n  useEffect(() => {\n    if (!open) setTimeout(() => setValue(''), 150)\n  }, [open])\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: need filters to be updated\n  const content = useMemo(\n    () =>\n      property && column ? (\n        <FilterValueController\n          filter={filter!}\n          column={column as Column<TData, ColumnDataType>}\n          actions={actions}\n          strategy={strategy}\n        />\n      ) : (\n        <Command loop>\n          <CommandInput\n            value={value}\n            onValueChange={setValue}\n            ref={inputRef}\n            placeholder=\"Search...\"\n          />\n          <CommandEmpty>No results.</CommandEmpty>\n          <CommandList className=\"max-h-fit\">\n            <CommandGroup>\n              {columns.map((column) => (\n                <FilterableColumn\n                  key={column.id}\n                  column={column}\n                  setProperty={setProperty}\n                />\n              ))}\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      ),\n    [property, column, filter, filters, columns, actions, value],\n  )\n\n  return (\n    <Popover\n      open={open}\n      onOpenChange={async (value) => {\n        setOpen(value)\n        if (!value) setTimeout(() => setProperty(undefined), 100)\n      }}\n    >\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline\"\n          className={cn('h-7', hasFilters && 'w-fit !px-2')}\n        >\n          <FilterIcon className=\"size-4\" />\n          {!hasFilters && <span>Filter</span>}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        side=\"bottom\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        {content}\n      </PopoverContent>\n    </Popover>\n  )\n}\n\nexport function FilterableColumn<TData, TType extends ColumnDataType, TVal>({\n  column,\n  setProperty,\n}: {\n  column: Column<TData, TType, TVal>\n  setProperty: (value: string) => void\n}) {\n  const itemRef = useRef<HTMLDivElement>(null)\n\n  const prefetch = useCallback(() => {\n    column.prefetchOptions()\n    column.prefetchValues()\n    column.prefetchFacetedUniqueValues()\n  }, [column])\n\n  useEffect(() => {\n    const target = itemRef.current\n\n    if (!target) return\n\n    // Set up MutationObserver\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'attributes') {\n          const isSelected = target.getAttribute('data-selected') === 'true'\n          if (isSelected) prefetch()\n        }\n      }\n    })\n\n    // Set up observer\n    observer.observe(target, {\n      attributes: true,\n      attributeFilter: ['data-selected'],\n    })\n\n    // Cleanup on unmount\n    return () => observer.disconnect()\n  }, [prefetch])\n\n  return (\n    <CommandItem\n      ref={itemRef}\n      onSelect={() => setProperty(column.id)}\n      className=\"group\"\n      onMouseEnter={prefetch}\n    >\n      <div className=\"flex w-full items-center justify-between\">\n        <div className=\"inline-flex items-center gap-1.5\">\n          {<column.icon strokeWidth={2.25} className=\"size-4\" />}\n          <span>{column.displayName}</span>\n        </div>\n        <ArrowRightIcon className=\"size-4 opacity-0 group-aria-selected:opacity-100\" />\n      </div>\n    </CommandItem>\n  )\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-selector.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/components/filter-subject.tsx",
      "content": "import type { Column, ColumnDataType } from '../core/types'\r\n\r\ninterface FilterSubjectProps<TData, TType extends ColumnDataType> {\r\n  column: Column<TData, TType>\r\n}\r\n\r\nexport function FilterSubject<TData, TType extends ColumnDataType>({\r\n  column,\r\n}: FilterSubjectProps<TData, TType>) {\r\n  const hasIcon = !!column.icon\r\n  return (\r\n    <span className=\"flex select-none items-center gap-1 whitespace-nowrap px-2 font-medium\">\r\n      {hasIcon && <column.icon className=\"size-4 stroke-[2.25px]\" />}\r\n      <span>{column.displayName}</span>\r\n    </span>\r\n  )\r\n}\r\n",
=======
      "path": "registry/data-table-filter/components/filter-subject.tsx",
      "content": "import type { Column, ColumnDataType } from '../core/types'\n\ninterface FilterSubjectProps<TData, TType extends ColumnDataType> {\n  column: Column<TData, TType>\n}\n\nexport function FilterSubject<TData, TType extends ColumnDataType>({\n  column,\n}: FilterSubjectProps<TData, TType>) {\n  const hasIcon = !!column.icon\n  return (\n    <span className=\"flex select-none items-center gap-1 whitespace-nowrap px-2 font-medium\">\n      {hasIcon && <column.icon className=\"size-4 stroke-[2.25px]\" />}\n      <span>{column.displayName}</span>\n    </span>\n  )\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-subject.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/components/filter-value.tsx",
      "content": "import { Button } from '@/components/ui/button'\r\nimport { Calendar } from '@/components/ui/calendar'\r\nimport { Checkbox } from '@/components/ui/checkbox'\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from '@/components/ui/command'\r\nimport { Input } from '@/components/ui/input'\r\nimport {\r\n  Popover,\r\n  PopoverAnchor,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/components/ui/popover'\r\nimport { Slider } from '@/components/ui/slider'\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'\r\nimport { cn } from '@/lib/utils'\r\nimport { isEqual } from 'date-fns'\r\nimport { format } from 'date-fns'\r\nimport { Ellipsis } from 'lucide-react'\r\nimport {\r\n  cloneElement,\r\n  isValidElement,\r\n  memo,\r\n  useCallback,\r\n  useEffect,\r\n  useMemo,\r\n  useState,\r\n} from 'react'\r\nimport type { DateRange } from 'react-day-picker'\r\nimport type {\r\n  Column,\r\n  ColumnDataType,\r\n  DataTableFilterActions,\r\n  FilterModel,\r\n  FilterStrategy,\r\n} from '../core/types'\r\nimport { take } from '../lib/array'\r\nimport { DebouncedInput } from '../ui/debounced-input'\r\nimport { Locale, t } from '../lib/i18n'\r\nimport { getNumberFilterDetails } from '../core/operators'\r\n\r\ninterface FilterValueProps<TData, TType extends ColumnDataType> {\r\n  filter: FilterModel<TType>\r\n  column: Column<TData, TType>\r\n  actions: DataTableFilterActions\r\n  strategy: FilterStrategy\r\n  locale: Locale\r\n}\r\n\r\nexport const FilterValue = memo(__FilterValue) as typeof __FilterValue\r\n\r\nfunction __FilterValue<TData, TType extends ColumnDataType>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  strategy,\r\n  locale,\r\n}: FilterValueProps<TData, TType>) {\r\n  return (\r\n    <Popover>\r\n      <PopoverAnchor className=\"h-full\" />\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          variant=\"ghost\"\r\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\r\n        >\r\n          <FilterValueDisplay\r\n            filter={filter}\r\n            column={column}\r\n            actions={actions}\r\n            locale={locale}\r\n          />\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent\r\n        align=\"start\"\r\n        side=\"bottom\"\r\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\r\n      >\r\n        <FilterValueController\r\n          filter={filter}\r\n          column={column}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n      </PopoverContent>\r\n    </Popover>\r\n  )\r\n}\r\n\r\ninterface FilterValueDisplayProps<TData, TType extends ColumnDataType> {\r\n  filter: FilterModel<TType>\r\n  column: Column<TData, TType>\r\n  actions: DataTableFilterActions\r\n  locale: Locale\r\n}\r\n\r\nexport function FilterValueDisplay<TData, TType extends ColumnDataType>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  locale,\r\n}: FilterValueDisplayProps<TData, TType>) {\r\n  switch (column.type) {\r\n    case 'option':\r\n      return (\r\n        <FilterValueOptionDisplay\r\n          filter={filter as FilterModel<'option'>}\r\n          column={column as Column<TData, 'option'>}\r\n          actions={actions}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'multiOption':\r\n      return (\r\n        <FilterValueMultiOptionDisplay\r\n          filter={filter as FilterModel<'multiOption'>}\r\n          column={column as Column<TData, 'multiOption'>}\r\n          actions={actions}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'date':\r\n      return (\r\n        <FilterValueDateDisplay\r\n          filter={filter as FilterModel<'date'>}\r\n          column={column as Column<TData, 'date'>}\r\n          actions={actions}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'text':\r\n      return (\r\n        <FilterValueTextDisplay\r\n          filter={filter as FilterModel<'text'>}\r\n          column={column as Column<TData, 'text'>}\r\n          actions={actions}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'number':\r\n      return (\r\n        <FilterValueNumberDisplay\r\n          filter={filter as FilterModel<'number'>}\r\n          column={column as Column<TData, 'number'>}\r\n          actions={actions}\r\n          locale={locale}\r\n        />\r\n      )\r\n    default:\r\n      return null\r\n  }\r\n}\r\n\r\nexport function FilterValueOptionDisplay<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  locale,\r\n}: FilterValueDisplayProps<TData, 'option'>) {\r\n  const options = useMemo(() => column.getOptions(), [column])\r\n  const selected = options.filter((o) => filter?.values.includes(o.value))\r\n\r\n  // We display the selected options based on how many are selected\r\n  //\r\n  // If there is only one option selected, we display its icon and label\r\n  //\r\n  // If there are multiple options selected, we display:\r\n  // 1) up to 3 icons of the selected options\r\n  // 2) the number of selected options\r\n  if (selected.length === 1) {\r\n    const { label, icon: Icon } = selected[0]\r\n    const hasIcon = !!Icon\r\n    return (\r\n      <span className=\"inline-flex items-center gap-1\">\r\n        {hasIcon &&\r\n          (isValidElement(Icon) ? (\r\n            Icon\r\n          ) : (\r\n            <Icon className=\"size-4 text-primary\" />\r\n          ))}\r\n        <span>{label}</span>\r\n      </span>\r\n    )\r\n  }\r\n  const name = column.displayName.toLowerCase()\r\n  // TODO: Better pluralization for different languages\r\n  const pluralName = name.endsWith('s') ? `${name}es` : `${name}s`\r\n\r\n  const hasOptionIcons = !options?.some((o) => !o.icon)\r\n\r\n  return (\r\n    <div className=\"inline-flex items-center gap-0.5\">\r\n      {hasOptionIcons &&\r\n        take(selected, 3).map(({ value, icon }) => {\r\n          const Icon = icon!\r\n          return isValidElement(Icon) ? (\r\n            Icon\r\n          ) : (\r\n            <Icon key={value} className=\"size-4\" />\r\n          )\r\n        })}\r\n      <span className={cn(hasOptionIcons && 'ml-1.5')}>\r\n        {selected.length} {pluralName}\r\n      </span>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport function FilterValueMultiOptionDisplay<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  locale,\r\n}: FilterValueDisplayProps<TData, 'multiOption'>) {\r\n  const options = useMemo(() => column.getOptions(), [column])\r\n  const selected = options.filter((o) => filter.values.includes(o.value))\r\n\r\n  if (selected.length === 1) {\r\n    const { label, icon: Icon } = selected[0]\r\n    const hasIcon = !!Icon\r\n    return (\r\n      <span className=\"inline-flex items-center gap-1.5\">\r\n        {hasIcon &&\r\n          (isValidElement(Icon) ? (\r\n            Icon\r\n          ) : (\r\n            <Icon className=\"size-4 text-primary\" />\r\n          ))}\r\n\r\n        <span>{label}</span>\r\n      </span>\r\n    )\r\n  }\r\n\r\n  const name = column.displayName.toLowerCase()\r\n\r\n  const hasOptionIcons = !options?.some((o) => !o.icon)\r\n\r\n  return (\r\n    <div className=\"inline-flex items-center gap-1.5\">\r\n      {hasOptionIcons && (\r\n        <div key=\"icons\" className=\"inline-flex items-center gap-0.5\">\r\n          {take(selected, 3).map(({ value, icon }) => {\r\n            const Icon = icon!\r\n            return isValidElement(Icon) ? (\r\n              cloneElement(Icon, { key: value })\r\n            ) : (\r\n              <Icon key={value} className=\"size-4\" />\r\n            )\r\n          })}\r\n        </div>\r\n      )}\r\n      <span>\r\n        {selected.length} {name}\r\n      </span>\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction formatDateRange(start: Date, end: Date) {\r\n  const sameMonth = start.getMonth() === end.getMonth()\r\n  const sameYear = start.getFullYear() === end.getFullYear()\r\n\r\n  if (sameMonth && sameYear) {\r\n    return `${format(start, 'MMM d')} - ${format(end, 'd, yyyy')}`\r\n  }\r\n\r\n  if (sameYear) {\r\n    return `${format(start, 'MMM d')} - ${format(end, 'MMM d, yyyy')}`\r\n  }\r\n\r\n  return `${format(start, 'MMM d, yyyy')} - ${format(end, 'MMM d, yyyy')}`\r\n}\r\n\r\nexport function FilterValueDateDisplay<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  locale,\r\n}: FilterValueDisplayProps<TData, 'date'>) {\r\n  if (!filter) return null\r\n  if (filter.values.length === 0) return <Ellipsis className=\"size-4\" />\r\n  if (filter.values.length === 1) {\r\n    const value = filter.values[0]\r\n\r\n    const formattedDateStr = format(value, 'MMM d, yyyy')\r\n\r\n    return <span>{formattedDateStr}</span>\r\n  }\r\n\r\n  const formattedRangeStr = formatDateRange(filter.values[0], filter.values[1])\r\n\r\n  return <span>{formattedRangeStr}</span>\r\n}\r\n\r\nexport function FilterValueTextDisplay<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  locale,\r\n}: FilterValueDisplayProps<TData, 'text'>) {\r\n  if (!filter) return null\r\n  if (filter.values.length === 0 || filter.values[0].trim() === '')\r\n    return <Ellipsis className=\"size-4\" />\r\n\r\n  const value = filter.values[0]\r\n\r\n  return <span>{value}</span>\r\n}\r\n\r\nexport function FilterValueNumberDisplay<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  locale,\r\n}: FilterValueDisplayProps<TData, 'number'>) {\r\n  const maxFromMeta = column.max\r\n  const cappedMax = maxFromMeta ?? 2147483647\r\n\r\n  if (!filter) return null\r\n\r\n  if (\r\n    filter.operator === 'is between' ||\r\n    filter.operator === 'is not between'\r\n  ) {\r\n    const minValue = filter.values[0]\r\n    const maxValue =\r\n      filter.values[1] === Number.POSITIVE_INFINITY ||\r\n      filter.values[1] >= cappedMax\r\n        ? `${cappedMax}+`\r\n        : filter.values[1]\r\n\r\n    return (\r\n      <span className=\"tabular-nums tracking-tight\">\r\n        {minValue} {t(\"and\", locale)} {maxValue}\r\n      </span>\r\n    )\r\n  }\r\n\r\n  if (!filter.values || filter.values.length === 0) {\r\n    return null\r\n  }\r\n\r\n  const value = filter.values[0]\r\n  return <span className=\"tabular-nums tracking-tight\">{value}</span>\r\n}\r\n\r\n/****** Property Filter Value Controller ******/\r\n\r\ninterface FilterValueControllerProps<TData, TType extends ColumnDataType> {\r\n  filter: FilterModel<TType>\r\n  column: Column<TData, TType>\r\n  actions: DataTableFilterActions\r\n  strategy: FilterStrategy\r\n  locale: Locale\r\n}\r\n\r\nexport const FilterValueController = memo(\r\n  __FilterValueController,\r\n) as typeof __FilterValueController\r\n\r\nfunction __FilterValueController<TData, TType extends ColumnDataType>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  strategy,\r\n  locale,\r\n}: FilterValueControllerProps<TData, TType>) {\r\n  switch (column.type) {\r\n    case 'option':\r\n      return (\r\n        <FilterValueOptionController\r\n          filter={filter as FilterModel<'option'>}\r\n          column={column as Column<TData, 'option'>}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'multiOption':\r\n      return (\r\n        <FilterValueMultiOptionController\r\n          filter={filter as FilterModel<'multiOption'>}\r\n          column={column as Column<TData, 'multiOption'>}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'date':\r\n      return (\r\n        <FilterValueDateController\r\n          filter={filter as FilterModel<'date'>}\r\n          column={column as Column<TData, 'date'>}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'text':\r\n      return (\r\n        <FilterValueTextController\r\n          filter={filter as FilterModel<'text'>}\r\n          column={column as Column<TData, 'text'>}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n      )\r\n    case 'number':\r\n      return (\r\n        <FilterValueNumberController\r\n          filter={filter as FilterModel<'number'>}\r\n          column={column as Column<TData, 'number'>}\r\n          actions={actions}\r\n          strategy={strategy}\r\n          locale={locale}\r\n        />\r\n      )\r\n    default:\r\n      return null\r\n  }\r\n}\r\n\r\nexport function FilterValueOptionController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  strategy,\r\n  locale,\r\n}: FilterValueControllerProps<TData, 'option'>) {\r\n  const options = useMemo(() => column.getOptions(), [column])\r\n  const optionsCount = useMemo(() => column.getFacetedUniqueValues(), [column])\r\n\r\n  function handleOptionSelect(value: string, check: boolean) {\r\n    if (check) actions.addFilterValue(column, [value])\r\n    else actions.removeFilterValue(column, [value])\r\n  }\r\n\r\n  return (\r\n    <Command loop>\r\n      <CommandInput autoFocus placeholder={t(\"search\", locale)} />\r\n      <CommandEmpty>{t(\"noresults\", locale)}</CommandEmpty>\r\n      <CommandList className=\"max-h-fit\">\r\n        <CommandGroup>\r\n          {options.map((v) => {\r\n            const checked = Boolean(filter?.values.includes(v.value))\r\n            const count = optionsCount?.get(v.value) ?? 0\r\n\r\n            return (\r\n              <CommandItem\r\n                key={v.value}\r\n                onSelect={() => {\r\n                  handleOptionSelect(v.value, !checked)\r\n                }}\r\n                className=\"group flex items-center justify-between gap-1.5\"\r\n              >\r\n                <div className=\"flex items-center gap-1.5\">\r\n                  <Checkbox\r\n                    checked={checked}\r\n                    className=\"opacity-0 group-hover:opacity-100 data-[state=checked]:opacity-100\"\r\n                  />\r\n                  {v.icon &&\r\n                    (isValidElement(v.icon) ? (\r\n                      v.icon\r\n                    ) : (\r\n                      <v.icon className=\"size-4 text-primary\" />\r\n                    ))}\r\n                  <span>\r\n                    {v.label}\r\n                    <sup\r\n                      className={cn(\r\n                        !optionsCount && 'hidden',\r\n                        'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\r\n                        count === 0 && 'slashed-zero',\r\n                      )}\r\n                    >\r\n                      {count < 100 ? count : '100+'}\r\n                    </sup>\r\n                  </span>\r\n                </div>\r\n              </CommandItem>\r\n            )\r\n          })}\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n\r\nexport function FilterValueMultiOptionController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  strategy,\r\n  locale,\r\n}: FilterValueControllerProps<TData, 'multiOption'>) {\r\n  const options = useMemo(() => column.getOptions(), [column])\r\n  const optionsCount = useMemo(() => column.getFacetedUniqueValues(), [column])\r\n\r\n  // Handles the selection/deselection of an option\r\n  function handleOptionSelect(value: string, check: boolean) {\r\n    if (check) actions.addFilterValue(column, [value])\r\n    else actions.removeFilterValue(column, [value])\r\n  }\r\n\r\n  return (\r\n    <Command loop>\r\n      <CommandInput autoFocus placeholder={t(\"search\", locale)} />\r\n      <CommandEmpty>{t(\"noresults\", locale)}</CommandEmpty>\r\n      <CommandList>\r\n        <CommandGroup>\r\n          {options.map((v) => {\r\n            const checked = Boolean(filter?.values?.includes(v.value))\r\n            const count = optionsCount?.get(v.value) ?? 0\r\n\r\n            return (\r\n              <CommandItem\r\n                key={v.value}\r\n                onSelect={() => {\r\n                  handleOptionSelect(v.value, !checked)\r\n                }}\r\n                className=\"group flex items-center justify-between gap-1.5\"\r\n              >\r\n                <div className=\"flex items-center gap-1.5\">\r\n                  <Checkbox\r\n                    checked={checked}\r\n                    className=\"opacity-0 group-hover:opacity-100 data-[state=checked]:opacity-100\"\r\n                  />\r\n                  {v.icon &&\r\n                    (isValidElement(v.icon) ? (\r\n                      v.icon\r\n                    ) : (\r\n                      <v.icon className=\"size-4 text-primary\" />\r\n                    ))}\r\n                  <span>\r\n                    {v.label}\r\n                    <sup\r\n                      className={cn(\r\n                        !optionsCount && 'hidden',\r\n                        'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\r\n                        count === 0 && 'slashed-zero',\r\n                      )}\r\n                    >\r\n                      {count < 100 ? count : '100+'}\r\n                    </sup>\r\n                  </span>\r\n                </div>\r\n              </CommandItem>\r\n            )\r\n          })}\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n\r\nexport function FilterValueDateController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n}: FilterValueControllerProps<TData, 'date'>) {\r\n  const [date, setDate] = useState<DateRange | undefined>({\r\n    from: filter?.values[0] ?? new Date(),\r\n    to: filter?.values[1] ?? undefined,\r\n  })\r\n\r\n  function changeDateRange(value: DateRange | undefined) {\r\n    const start = value?.from\r\n    const end =\r\n      start && value && value.to && !isEqual(start, value.to)\r\n        ? value.to\r\n        : undefined\r\n\r\n    setDate({ from: start, to: end })\r\n\r\n    const isRange = start && end\r\n    const newValues = isRange ? [start, end] : start ? [start] : []\r\n\r\n    actions.setFilterValue(column, newValues)\r\n  }\r\n\r\n  return (\r\n    <Command>\r\n      <CommandList className=\"max-h-fit\">\r\n        <CommandGroup>\r\n          <div>\r\n            <Calendar\r\n              initialFocus\r\n              mode=\"range\"\r\n              defaultMonth={date?.from}\r\n              selected={date}\r\n              onSelect={changeDateRange}\r\n              numberOfMonths={1}\r\n            />\r\n          </div>\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n\r\nexport function FilterValueTextController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  locale,\r\n}: FilterValueControllerProps<TData, 'text'>) {\r\n  const changeText = (value: string | number) => {\r\n    actions.setFilterValue(column, [String(value)])\r\n  }\r\n\r\n  return (\r\n    <Command>\r\n      <CommandList className=\"max-h-fit\">\r\n        <CommandGroup>\r\n          <CommandItem>\r\n            <DebouncedInput\r\n              placeholder={t(\"search\", locale)}\r\n              autoFocus\r\n              value={filter?.values[0] ?? ''}\r\n              onChange={changeText}\r\n            />\r\n          </CommandItem>\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n\r\nexport function FilterValueNumberController<TData>({\r\n  filter,\r\n  column,\r\n  actions,\r\n  locale,\r\n}: FilterValueControllerProps<TData, 'number'>) {\r\n  const [datasetMin, datasetMax] = useMemo(\r\n    () => column.getFacetedMinMaxValues(),\r\n    [column],\r\n  )\r\n  const [sliderMin, sliderMax] = [\r\n    column.min ?? datasetMin,\r\n    column.max ?? datasetMax,\r\n  ]\r\n\r\n  // Local state for values\r\n  const [values, setValues] = useState(filter?.values ?? [0, 0])\r\n\r\n  // Sync with parent filter changes\r\n  useEffect(() => {\r\n    if (\r\n      filter?.values &&\r\n      filter.values.length === values.length &&\r\n      filter.values.every((v, i) => v === values[i])\r\n    ) {\r\n      setValues(filter.values)\r\n    }\r\n  }, [filter?.values, values])\r\n\r\n  const isNumberRange =\r\n    filter && getNumberFilterDetails(locale)[filter.operator].target === 'multiple'\r\n\r\n  const changeNumber = (value: number[]) => {\r\n    setValues(value)\r\n    actions.setFilterValue(column, value)\r\n  }\r\n\r\n  const changeMinNumber = (value: number) => {\r\n    const newValues = [value, values[1]]\r\n    setValues(newValues)\r\n    actions.setFilterValue(column, newValues)\r\n  }\r\n\r\n  const changeMaxNumber = (value: number) => {\r\n    const newValues = [values[0], value]\r\n    setValues(newValues)\r\n    actions.setFilterValue(column, newValues)\r\n  }\r\n\r\n  const changeType = useCallback(\r\n    (type: 'single' | 'range') => {\r\n      const newValues =\r\n        type === 'single'\r\n          ? [values[0]] // Keep the first value for single mode\r\n          : [values[0], values[1] ?? datasetMax] // Use two values for range mode\r\n      const newOperator = type === 'single' ? 'is' : 'is between'\r\n\r\n      // Update local state\r\n      setValues(newValues)\r\n\r\n      // Update global filter state atomically\r\n      actions.setFilterOperator(column.id, newOperator)\r\n      actions.setFilterValue(column, newValues)\r\n    },\r\n    [values, datasetMax, column, actions],\r\n  )\r\n\r\n  return (\r\n    <Command>\r\n      <CommandList className=\"w-[300px] px-2 py-2\">\r\n        <CommandGroup>\r\n          <div className=\"flex flex-col w-full\">\r\n            <Tabs\r\n              value={isNumberRange ? 'range' : 'single'}\r\n              onValueChange={(v) => changeType(v as 'single' | 'range')}\r\n            >\r\n              <TabsList className=\"w-full *:text-xs\">\r\n                <TabsTrigger value=\"single\">{t(\"single\", locale)}</TabsTrigger>\r\n                <TabsTrigger value=\"range\">{t(\"range\", locale)}</TabsTrigger>\r\n              </TabsList>\r\n              <TabsContent value=\"single\" className=\"flex flex-col gap-4 mt-4\">\r\n                <Slider\r\n                  value={[values[0]]}\r\n                  onValueChange={(value) => changeNumber(value)}\r\n                  min={sliderMin}\r\n                  max={sliderMax}\r\n                  step={1}\r\n                  aria-orientation=\"horizontal\"\r\n                />\r\n                <div className=\"flex items-center gap-2\">\r\n                  <span className=\"text-xs font-medium\">{t(\"value\", locale)}</span>\r\n                  <Input\r\n                    id=\"single\"\r\n                    type=\"number\"\r\n                    value={values[0].toString()} // Use values[0] directly\r\n                    onChange={(e) => changeNumber([Number(e.target.value)])}\r\n                    min={datasetMin}\r\n                    max={datasetMax}\r\n                  />\r\n                </div>\r\n              </TabsContent>\r\n              <TabsContent value=\"range\" className=\"flex flex-col gap-4 mt-4\">\r\n                <Slider\r\n                  value={values} // Use values directly\r\n                  onValueChange={changeNumber}\r\n                  min={sliderMin}\r\n                  max={sliderMax}\r\n                  step={1}\r\n                  aria-orientation=\"horizontal\"\r\n                />\r\n                <div className=\"grid grid-cols-2 gap-4\">\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <span className=\"text-xs font-medium\">{t(\"min\", locale)}</span>\r\n                    <DebouncedInput\r\n                      type=\"number\"\r\n                      value={values[0]}\r\n                      onChange={(v) => changeMinNumber(Number(v))}\r\n                      min={datasetMin}\r\n                      max={datasetMax}\r\n                    />\r\n                  </div>\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <span className=\"text-xs font-medium\">{t(\"max\", locale)}</span>\r\n                    <DebouncedInput\r\n                      type=\"number\"\r\n                      value={values[1]}\r\n                      onChange={(v) => changeMaxNumber(Number(v))}\r\n                      min={datasetMin}\r\n                      max={datasetMax}\r\n                    />\r\n                  </div>\r\n                </div>\r\n              </TabsContent>\r\n            </Tabs>\r\n          </div>\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n",
=======
      "path": "registry/data-table-filter/components/filter-value.tsx",
      "content": "import { Button } from '@/components/ui/button'\nimport { Calendar } from '@/components/ui/calendar'\nimport { Checkbox } from '@/components/ui/checkbox'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport { Input } from '@/components/ui/input'\nimport {\n  Popover,\n  PopoverAnchor,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport { Slider } from '@/components/ui/slider'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'\nimport { cn } from '@/lib/utils'\nimport { isEqual } from 'date-fns'\nimport { format } from 'date-fns'\nimport { Ellipsis } from 'lucide-react'\nimport {\n  cloneElement,\n  isValidElement,\n  memo,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react'\nimport type { DateRange } from 'react-day-picker'\nimport { numberFilterDetails } from '../core/operators'\nimport type {\n  Column,\n  ColumnDataType,\n  DataTableFilterActions,\n  FilterModel,\n  FilterStrategy,\n} from '../core/types'\nimport { take } from '../lib/array'\nimport { DebouncedInput } from '../ui/debounced-input'\n\ninterface FilterValueProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n}\n\nexport const FilterValue = memo(__FilterValue) as typeof __FilterValue\n\nfunction __FilterValue<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  strategy,\n}: FilterValueProps<TData, TType>) {\n  return (\n    <Popover>\n      <PopoverAnchor className=\"h-full\" />\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"ghost\"\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\n        >\n          <FilterValueDisplay\n            filter={filter}\n            column={column}\n            actions={actions}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        align=\"start\"\n        side=\"bottom\"\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\n      >\n        <FilterValueController\n          filter={filter}\n          column={column}\n          actions={actions}\n          strategy={strategy}\n        />\n      </PopoverContent>\n    </Popover>\n  )\n}\n\ninterface FilterValueDisplayProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n}\n\nexport function FilterValueDisplay<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n}: FilterValueDisplayProps<TData, TType>) {\n  switch (column.type) {\n    case 'option':\n      return (\n        <FilterValueOptionDisplay\n          filter={filter as FilterModel<'option'>}\n          column={column as Column<TData, 'option'>}\n          actions={actions}\n        />\n      )\n    case 'multiOption':\n      return (\n        <FilterValueMultiOptionDisplay\n          filter={filter as FilterModel<'multiOption'>}\n          column={column as Column<TData, 'multiOption'>}\n          actions={actions}\n        />\n      )\n    case 'date':\n      return (\n        <FilterValueDateDisplay\n          filter={filter as FilterModel<'date'>}\n          column={column as Column<TData, 'date'>}\n          actions={actions}\n        />\n      )\n    case 'text':\n      return (\n        <FilterValueTextDisplay\n          filter={filter as FilterModel<'text'>}\n          column={column as Column<TData, 'text'>}\n          actions={actions}\n        />\n      )\n    case 'number':\n      return (\n        <FilterValueNumberDisplay\n          filter={filter as FilterModel<'number'>}\n          column={column as Column<TData, 'number'>}\n          actions={actions}\n        />\n      )\n    default:\n      return null\n  }\n}\n\nexport function FilterValueOptionDisplay<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueDisplayProps<TData, 'option'>) {\n  const options = useMemo(() => column.getOptions(), [column])\n  const selected = options.filter((o) => filter?.values.includes(o.value))\n\n  // We display the selected options based on how many are selected\n  //\n  // If there is only one option selected, we display its icon and label\n  //\n  // If there are multiple options selected, we display:\n  // 1) up to 3 icons of the selected options\n  // 2) the number of selected options\n  if (selected.length === 1) {\n    const { label, icon: Icon } = selected[0]\n    const hasIcon = !!Icon\n    return (\n      <span className=\"inline-flex items-center gap-1\">\n        {hasIcon &&\n          (isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon className=\"size-4 text-primary\" />\n          ))}\n        <span>{label}</span>\n      </span>\n    )\n  }\n  const name = column.displayName.toLowerCase()\n  const pluralName = name.endsWith('s') ? `${name}es` : `${name}s`\n\n  const hasOptionIcons = !options?.some((o) => !o.icon)\n\n  return (\n    <div className=\"inline-flex items-center gap-0.5\">\n      {hasOptionIcons &&\n        take(selected, 3).map(({ value, icon }) => {\n          const Icon = icon!\n          return isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon key={value} className=\"size-4\" />\n          )\n        })}\n      <span className={cn(hasOptionIcons && 'ml-1.5')}>\n        {selected.length} {pluralName}\n      </span>\n    </div>\n  )\n}\n\nexport function FilterValueMultiOptionDisplay<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueDisplayProps<TData, 'multiOption'>) {\n  const options = useMemo(() => column.getOptions(), [column])\n  const selected = options.filter((o) => filter.values.includes(o.value))\n\n  if (selected.length === 1) {\n    const { label, icon: Icon } = selected[0]\n    const hasIcon = !!Icon\n    return (\n      <span className=\"inline-flex items-center gap-1.5\">\n        {hasIcon &&\n          (isValidElement(Icon) ? (\n            Icon\n          ) : (\n            <Icon className=\"size-4 text-primary\" />\n          ))}\n\n        <span>{label}</span>\n      </span>\n    )\n  }\n\n  const name = column.displayName.toLowerCase()\n\n  const hasOptionIcons = !options?.some((o) => !o.icon)\n\n  return (\n    <div className=\"inline-flex items-center gap-1.5\">\n      {hasOptionIcons && (\n        <div key=\"icons\" className=\"inline-flex items-center gap-0.5\">\n          {take(selected, 3).map(({ value, icon }) => {\n            const Icon = icon!\n            return isValidElement(Icon) ? (\n              cloneElement(Icon, { key: value })\n            ) : (\n              <Icon key={value} className=\"size-4\" />\n            )\n          })}\n        </div>\n      )}\n      <span>\n        {selected.length} {name}\n      </span>\n    </div>\n  )\n}\n\nfunction formatDateRange(start: Date, end: Date) {\n  const sameMonth = start.getMonth() === end.getMonth()\n  const sameYear = start.getFullYear() === end.getFullYear()\n\n  if (sameMonth && sameYear) {\n    return `${format(start, 'MMM d')} - ${format(end, 'd, yyyy')}`\n  }\n\n  if (sameYear) {\n    return `${format(start, 'MMM d')} - ${format(end, 'MMM d, yyyy')}`\n  }\n\n  return `${format(start, 'MMM d, yyyy')} - ${format(end, 'MMM d, yyyy')}`\n}\n\nexport function FilterValueDateDisplay<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueDisplayProps<TData, 'date'>) {\n  if (!filter) return null\n  if (filter.values.length === 0) return <Ellipsis className=\"size-4\" />\n  if (filter.values.length === 1) {\n    const value = filter.values[0]\n\n    const formattedDateStr = format(value, 'MMM d, yyyy')\n\n    return <span>{formattedDateStr}</span>\n  }\n\n  const formattedRangeStr = formatDateRange(filter.values[0], filter.values[1])\n\n  return <span>{formattedRangeStr}</span>\n}\n\nexport function FilterValueTextDisplay<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueDisplayProps<TData, 'text'>) {\n  if (!filter) return null\n  if (filter.values.length === 0 || filter.values[0].trim() === '')\n    return <Ellipsis className=\"size-4\" />\n\n  const value = filter.values[0]\n\n  return <span>{value}</span>\n}\n\nexport function FilterValueNumberDisplay<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueDisplayProps<TData, 'number'>) {\n  const maxFromMeta = column.max\n  const cappedMax = maxFromMeta ?? 2147483647\n\n  if (!filter) return null\n\n  if (\n    filter.operator === 'is between' ||\n    filter.operator === 'is not between'\n  ) {\n    const minValue = filter.values[0]\n    const maxValue =\n      filter.values[1] === Number.POSITIVE_INFINITY ||\n      filter.values[1] >= cappedMax\n        ? `${cappedMax}+`\n        : filter.values[1]\n\n    return (\n      <span className=\"tabular-nums tracking-tight\">\n        {minValue} and {maxValue}\n      </span>\n    )\n  }\n\n  if (!filter.values || filter.values.length === 0) {\n    return null\n  }\n\n  const value = filter.values[0]\n  return <span className=\"tabular-nums tracking-tight\">{value}</span>\n}\n\n/****** Property Filter Value Controller ******/\n\ninterface FilterValueControllerProps<TData, TType extends ColumnDataType> {\n  filter: FilterModel<TType>\n  column: Column<TData, TType>\n  actions: DataTableFilterActions\n  strategy: FilterStrategy\n}\n\nexport const FilterValueController = memo(\n  __FilterValueController,\n) as typeof __FilterValueController\n\nfunction __FilterValueController<TData, TType extends ColumnDataType>({\n  filter,\n  column,\n  actions,\n  strategy,\n}: FilterValueControllerProps<TData, TType>) {\n  switch (column.type) {\n    case 'option':\n      return (\n        <FilterValueOptionController\n          filter={filter as FilterModel<'option'>}\n          column={column as Column<TData, 'option'>}\n          actions={actions}\n          strategy={strategy}\n        />\n      )\n    case 'multiOption':\n      return (\n        <FilterValueMultiOptionController\n          filter={filter as FilterModel<'multiOption'>}\n          column={column as Column<TData, 'multiOption'>}\n          actions={actions}\n          strategy={strategy}\n        />\n      )\n    case 'date':\n      return (\n        <FilterValueDateController\n          filter={filter as FilterModel<'date'>}\n          column={column as Column<TData, 'date'>}\n          actions={actions}\n          strategy={strategy}\n        />\n      )\n    case 'text':\n      return (\n        <FilterValueTextController\n          filter={filter as FilterModel<'text'>}\n          column={column as Column<TData, 'text'>}\n          actions={actions}\n          strategy={strategy}\n        />\n      )\n    case 'number':\n      return (\n        <FilterValueNumberController\n          filter={filter as FilterModel<'number'>}\n          column={column as Column<TData, 'number'>}\n          actions={actions}\n          strategy={strategy}\n        />\n      )\n    default:\n      return null\n  }\n}\n\nexport function FilterValueOptionController<TData>({\n  filter,\n  column,\n  actions,\n  strategy,\n}: FilterValueControllerProps<TData, 'option'>) {\n  const options = useMemo(() => column.getOptions(), [column])\n  const optionsCount = useMemo(() => column.getFacetedUniqueValues(), [column])\n\n  function handleOptionSelect(value: string, check: boolean) {\n    if (check) actions.addFilterValue(column, [value])\n    else actions.removeFilterValue(column, [value])\n  }\n\n  return (\n    <Command loop>\n      <CommandInput autoFocus placeholder=\"Search...\" />\n      <CommandEmpty>No results.</CommandEmpty>\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup>\n          {options.map((v) => {\n            const checked = Boolean(filter?.values.includes(v.value))\n            const count = optionsCount?.get(v.value) ?? 0\n\n            return (\n              <CommandItem\n                key={v.value}\n                onSelect={() => {\n                  handleOptionSelect(v.value, !checked)\n                }}\n                className=\"group flex items-center justify-between gap-1.5\"\n              >\n                <div className=\"flex items-center gap-1.5\">\n                  <Checkbox\n                    checked={checked}\n                    className=\"opacity-0 group-hover:opacity-100 data-[state=checked]:opacity-100\"\n                  />\n                  {v.icon &&\n                    (isValidElement(v.icon) ? (\n                      v.icon\n                    ) : (\n                      <v.icon className=\"size-4 text-primary\" />\n                    ))}\n                  <span>\n                    {v.label}\n                    <sup\n                      className={cn(\n                        !optionsCount && 'hidden',\n                        'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\n                        count === 0 && 'slashed-zero',\n                      )}\n                    >\n                      {count < 100 ? count : '100+'}\n                    </sup>\n                  </span>\n                </div>\n              </CommandItem>\n            )\n          })}\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function FilterValueMultiOptionController<TData>({\n  filter,\n  column,\n  actions,\n  strategy,\n}: FilterValueControllerProps<TData, 'multiOption'>) {\n  const options = useMemo(() => column.getOptions(), [column])\n  const optionsCount = useMemo(() => column.getFacetedUniqueValues(), [column])\n\n  // Handles the selection/deselection of an option\n  function handleOptionSelect(value: string, check: boolean) {\n    if (check) actions.addFilterValue(column, [value])\n    else actions.removeFilterValue(column, [value])\n  }\n\n  return (\n    <Command loop>\n      <CommandInput autoFocus placeholder=\"Search...\" />\n      <CommandEmpty>No results.</CommandEmpty>\n      <CommandList>\n        <CommandGroup>\n          {options.map((v) => {\n            const checked = Boolean(filter?.values?.includes(v.value))\n            const count = optionsCount?.get(v.value) ?? 0\n\n            return (\n              <CommandItem\n                key={v.value}\n                onSelect={() => {\n                  handleOptionSelect(v.value, !checked)\n                }}\n                className=\"group flex items-center justify-between gap-1.5\"\n              >\n                <div className=\"flex items-center gap-1.5\">\n                  <Checkbox\n                    checked={checked}\n                    className=\"opacity-0 group-hover:opacity-100 data-[state=checked]:opacity-100\"\n                  />\n                  {v.icon &&\n                    (isValidElement(v.icon) ? (\n                      v.icon\n                    ) : (\n                      <v.icon className=\"size-4 text-primary\" />\n                    ))}\n                  <span>\n                    {v.label}\n                    <sup\n                      className={cn(\n                        !optionsCount && 'hidden',\n                        'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\n                        count === 0 && 'slashed-zero',\n                      )}\n                    >\n                      {count < 100 ? count : '100+'}\n                    </sup>\n                  </span>\n                </div>\n              </CommandItem>\n            )\n          })}\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function FilterValueDateController<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueControllerProps<TData, 'date'>) {\n  const [date, setDate] = useState<DateRange | undefined>({\n    from: filter?.values[0] ?? new Date(),\n    to: filter?.values[1] ?? undefined,\n  })\n\n  function changeDateRange(value: DateRange | undefined) {\n    const start = value?.from\n    const end =\n      start && value && value.to && !isEqual(start, value.to)\n        ? value.to\n        : undefined\n\n    setDate({ from: start, to: end })\n\n    const isRange = start && end\n    const newValues = isRange ? [start, end] : start ? [start] : []\n\n    actions.setFilterValue(column, newValues)\n  }\n\n  return (\n    <Command>\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup>\n          <div>\n            <Calendar\n              initialFocus\n              mode=\"range\"\n              defaultMonth={date?.from}\n              selected={date}\n              onSelect={changeDateRange}\n              numberOfMonths={1}\n            />\n          </div>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function FilterValueTextController<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueControllerProps<TData, 'text'>) {\n  const changeText = (value: string | number) => {\n    actions.setFilterValue(column, [String(value)])\n  }\n\n  return (\n    <Command>\n      <CommandList className=\"max-h-fit\">\n        <CommandGroup>\n          <CommandItem>\n            <DebouncedInput\n              placeholder=\"Search...\"\n              autoFocus\n              value={filter?.values[0] ?? ''}\n              onChange={changeText}\n            />\n          </CommandItem>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n\nexport function FilterValueNumberController<TData>({\n  filter,\n  column,\n  actions,\n}: FilterValueControllerProps<TData, 'number'>) {\n  const [datasetMin, datasetMax] = useMemo(\n    () => column.getFacetedMinMaxValues(),\n    [column],\n  )\n  const [sliderMin, sliderMax] = [\n    column.min ?? datasetMin,\n    column.max ?? datasetMax,\n  ]\n\n  // Local state for values\n  const [values, setValues] = useState(filter?.values ?? [0, 0])\n\n  // Sync with parent filter changes\n  useEffect(() => {\n    if (\n      filter?.values &&\n      filter.values.length === values.length &&\n      filter.values.every((v, i) => v === values[i])\n    ) {\n      setValues(filter.values)\n    }\n  }, [filter?.values, values])\n\n  const isNumberRange =\n    filter && numberFilterDetails[filter.operator].target === 'multiple'\n\n  const changeNumber = (value: number[]) => {\n    setValues(value)\n    actions.setFilterValue(column, value)\n  }\n\n  const changeMinNumber = (value: number) => {\n    const newValues = [value, values[1]]\n    setValues(newValues)\n    actions.setFilterValue(column, newValues)\n  }\n\n  const changeMaxNumber = (value: number) => {\n    const newValues = [values[0], value]\n    setValues(newValues)\n    actions.setFilterValue(column, newValues)\n  }\n\n  const changeType = useCallback(\n    (type: 'single' | 'range') => {\n      const newValues =\n        type === 'single'\n          ? [values[0]] // Keep the first value for single mode\n          : [values[0], values[1] ?? datasetMax] // Use two values for range mode\n      const newOperator = type === 'single' ? 'is' : 'is between'\n\n      // Update local state\n      setValues(newValues)\n\n      // Update global filter state atomically\n      actions.setFilterOperator(column.id, newOperator)\n      actions.setFilterValue(column, newValues)\n    },\n    [values, datasetMax, column, actions],\n  )\n\n  return (\n    <Command>\n      <CommandList className=\"w-[300px] px-2 py-2\">\n        <CommandGroup>\n          <div className=\"flex flex-col w-full\">\n            <Tabs\n              value={isNumberRange ? 'range' : 'single'}\n              onValueChange={(v) => changeType(v as 'single' | 'range')}\n            >\n              <TabsList className=\"w-full *:text-xs\">\n                <TabsTrigger value=\"single\">Single</TabsTrigger>\n                <TabsTrigger value=\"range\">Range</TabsTrigger>\n              </TabsList>\n              <TabsContent value=\"single\" className=\"flex flex-col gap-4 mt-4\">\n                <Slider\n                  value={[values[0]]}\n                  onValueChange={(value) => changeNumber(value)}\n                  min={sliderMin}\n                  max={sliderMax}\n                  step={1}\n                  aria-orientation=\"horizontal\"\n                />\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"text-xs font-medium\">Value</span>\n                  <Input\n                    id=\"single\"\n                    type=\"number\"\n                    value={values[0].toString()} // Use values[0] directly\n                    onChange={(e) => changeNumber([Number(e.target.value)])}\n                    min={datasetMin}\n                    max={datasetMax}\n                  />\n                </div>\n              </TabsContent>\n              <TabsContent value=\"range\" className=\"flex flex-col gap-4 mt-4\">\n                <Slider\n                  value={values} // Use values directly\n                  onValueChange={changeNumber}\n                  min={sliderMin}\n                  max={sliderMax}\n                  step={1}\n                  aria-orientation=\"horizontal\"\n                />\n                <div className=\"grid grid-cols-2 gap-4\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-xs font-medium\">Min</span>\n                    <DebouncedInput\n                      type=\"number\"\n                      value={values[0]}\n                      onChange={(v) => changeMinNumber(Number(v))}\n                      min={datasetMin}\n                      max={datasetMax}\n                    />\n                  </div>\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-xs font-medium\">Max</span>\n                    <DebouncedInput\n                      type=\"number\"\n                      value={values[1]}\n                      onChange={(v) => changeMaxNumber(Number(v))}\n                      min={datasetMin}\n                      max={datasetMax}\n                    />\n                  </div>\n                </div>\n              </TabsContent>\n            </Tabs>\n          </div>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  )\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/components/filter-value.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/core/filters.ts",
      "content": "import { isAnyOf, uniq } from '../lib/array'\r\nimport { isColumnOptionArray } from '../lib/helpers'\r\nimport { memo } from '../lib/memo'\r\nimport type {\r\n  Column,\r\n  ColumnConfig,\r\n  ColumnDataType,\r\n  ColumnOption,\r\n  ElementType,\r\n  FilterStrategy,\r\n  Nullable,\r\n  TAccessorFn,\r\n  TOrderFn,\r\n  TTransformOptionFn,\r\n} from './types'\r\n\r\nclass ColumnConfigBuilder<\r\n  TData,\r\n  TType extends ColumnDataType = any,\r\n  TVal = unknown,\r\n  TId extends string = string, // Add TId generic\r\n> {\r\n  private config: Partial<ColumnConfig<TData, TType, TVal, TId>>\r\n\r\n  constructor(type: TType) {\r\n    this.config = { type } as Partial<ColumnConfig<TData, TType, TVal, TId>>\r\n  }\r\n\r\n  private clone(): ColumnConfigBuilder<TData, TType, TVal, TId> {\r\n    const newInstance = new ColumnConfigBuilder<TData, TType, TVal, TId>(\r\n      this.config.type as TType,\r\n    )\r\n    newInstance.config = { ...this.config }\r\n    return newInstance\r\n  }\r\n\r\n  id<TNewId extends string>(\r\n    value: TNewId,\r\n  ): ColumnConfigBuilder<TData, TType, TVal, TNewId> {\r\n    const newInstance = this.clone() as any // We'll refine this\r\n    newInstance.config.id = value\r\n    return newInstance as ColumnConfigBuilder<TData, TType, TVal, TNewId>\r\n  }\r\n\r\n  accessor<TNewVal>(\r\n    accessor: TAccessorFn<TData, TNewVal>,\r\n  ): ColumnConfigBuilder<TData, TType, TNewVal, TId> {\r\n    const newInstance = this.clone() as any\r\n    newInstance.config.accessor = accessor\r\n    return newInstance as ColumnConfigBuilder<TData, TType, TNewVal, TId>\r\n  }\r\n\r\n  displayName(value: string): ColumnConfigBuilder<TData, TType, TVal, TId> {\r\n    const newInstance = this.clone()\r\n    newInstance.config.displayName = value\r\n    return newInstance\r\n  }\r\n\r\n  icon(value: any): ColumnConfigBuilder<TData, TType, TVal, TId> {\r\n    const newInstance = this.clone()\r\n    newInstance.config.icon = value\r\n    return newInstance\r\n  }\r\n\r\n  min(\r\n    value: number,\r\n  ): ColumnConfigBuilder<\r\n    TData,\r\n    TType extends 'number' ? TType : never,\r\n    TVal,\r\n    TId\r\n  > {\r\n    if (this.config.type !== 'number') {\r\n      throw new Error('min() is only applicable to number columns')\r\n    }\r\n    const newInstance = this.clone() as any\r\n    newInstance.config.min = value\r\n    return newInstance\r\n  }\r\n\r\n  max(\r\n    value: number,\r\n  ): ColumnConfigBuilder<\r\n    TData,\r\n    TType extends 'number' ? TType : never,\r\n    TVal,\r\n    TId\r\n  > {\r\n    if (this.config.type !== 'number') {\r\n      throw new Error('max() is only applicable to number columns')\r\n    }\r\n    const newInstance = this.clone() as any\r\n    newInstance.config.max = value\r\n    return newInstance\r\n  }\r\n\r\n  options(\r\n    value: ColumnOption[],\r\n  ): ColumnConfigBuilder<\r\n    TData,\r\n    TType extends 'option' | 'multiOption' ? TType : never,\r\n    TVal,\r\n    TId\r\n  > {\r\n    if (!isAnyOf(this.config.type, ['option', 'multiOption'])) {\r\n      throw new Error(\r\n        'options() is only applicable to option or multiOption columns',\r\n      )\r\n    }\r\n    const newInstance = this.clone() as any\r\n    newInstance.config.options = value\r\n    return newInstance\r\n  }\r\n\r\n  transformOptionFn(\r\n    fn: TTransformOptionFn<TVal>,\r\n  ): ColumnConfigBuilder<\r\n    TData,\r\n    TType extends 'option' | 'multiOption' ? TType : never,\r\n    TVal,\r\n    TId\r\n  > {\r\n    if (!isAnyOf(this.config.type, ['option', 'multiOption'])) {\r\n      throw new Error(\r\n        'transformOptionFn() is only applicable to option or multiOption columns',\r\n      )\r\n    }\r\n    const newInstance = this.clone() as any\r\n    newInstance.config.transformOptionFn = fn\r\n    return newInstance\r\n  }\r\n\r\n  orderFn(\r\n    fn: TOrderFn<TVal>,\r\n  ): ColumnConfigBuilder<\r\n    TData,\r\n    TType extends 'option' | 'multiOption' ? TType : never,\r\n    TVal,\r\n    TId\r\n  > {\r\n    if (!isAnyOf(this.config.type, ['option', 'multiOption'])) {\r\n      throw new Error(\r\n        'orderFn() is only applicable to option or multiOption columns',\r\n      )\r\n    }\r\n    const newInstance = this.clone() as any\r\n    newInstance.config.orderFn = fn\r\n    return newInstance\r\n  }\r\n\r\n  build(): ColumnConfig<TData, TType, TVal, TId> {\r\n    if (!this.config.id) throw new Error('id is required')\r\n    if (!this.config.accessor) throw new Error('accessor is required')\r\n    if (!this.config.displayName) throw new Error('displayName is required')\r\n    if (!this.config.icon) throw new Error('icon is required')\r\n    return this.config as ColumnConfig<TData, TType, TVal, TId>\r\n  }\r\n}\r\n\r\n// Update the helper interface\r\ninterface FluentColumnConfigHelper<TData> {\r\n  text: () => ColumnConfigBuilder<TData, 'text', string>\r\n  number: () => ColumnConfigBuilder<TData, 'number', number>\r\n  date: () => ColumnConfigBuilder<TData, 'date', Date>\r\n  option: () => ColumnConfigBuilder<TData, 'option', string>\r\n  multiOption: () => ColumnConfigBuilder<TData, 'multiOption', string[]>\r\n}\r\n\r\n// Factory function remains mostly the same\r\nexport function createColumnConfigHelper<\r\n  TData,\r\n>(): FluentColumnConfigHelper<TData> {\r\n  return {\r\n    text: () => new ColumnConfigBuilder<TData, 'text', string>('text'),\r\n    number: () => new ColumnConfigBuilder<TData, 'number', number>('number'),\r\n    date: () => new ColumnConfigBuilder<TData, 'date', Date>('date'),\r\n    option: () => new ColumnConfigBuilder<TData, 'option', string>('option'),\r\n    multiOption: () =>\r\n      new ColumnConfigBuilder<TData, 'multiOption', string[]>('multiOption'),\r\n  }\r\n}\r\n\r\nexport function getColumnOptions<TData, TType extends ColumnDataType, TVal>(\r\n  column: ColumnConfig<TData, TType, TVal>,\r\n  data: TData[],\r\n  strategy: FilterStrategy,\r\n): ColumnOption[] {\r\n  if (!isAnyOf(column.type, ['option', 'multiOption'])) {\r\n    console.warn(\r\n      'Column options can only be retrieved for option and multiOption columns',\r\n    )\r\n    return []\r\n  }\r\n\r\n  if (strategy === 'server' && !column.options) {\r\n    throw new Error('column options are required for server-side filtering')\r\n  }\r\n\r\n  if (column.options) {\r\n    return column.options\r\n  }\r\n\r\n  const filtered = data\r\n    .flatMap(column.accessor)\r\n    .filter((v): v is NonNullable<TVal> => v !== undefined && v !== null)\r\n\r\n  let models = uniq(filtered)\r\n\r\n  if (column.orderFn) {\r\n    models = models.sort((m1, m2) =>\r\n      column.orderFn!(\r\n        m1 as ElementType<NonNullable<TVal>>,\r\n        m2 as ElementType<NonNullable<TVal>>,\r\n      ),\r\n    )\r\n  }\r\n\r\n  if (column.transformOptionFn) {\r\n    // Memoize transformOptionFn calls\r\n    const memoizedTransform = memo(\r\n      () => [models],\r\n      (deps) =>\r\n        deps[0].map((m) =>\r\n          column.transformOptionFn!(m as ElementType<NonNullable<TVal>>),\r\n        ),\r\n      { key: `transform-${column.id}` },\r\n    )\r\n    return memoizedTransform()\r\n  }\r\n\r\n  if (isColumnOptionArray(models)) return models\r\n\r\n  throw new Error(\r\n    `[data-table-filter] [${column.id}] Either provide static options, a transformOptionFn, or ensure the column data conforms to ColumnOption type`,\r\n  )\r\n}\r\n\r\nexport function getColumnValues<TData, TType extends ColumnDataType, TVal>(\r\n  column: ColumnConfig<TData, TType, TVal>,\r\n  data: TData[],\r\n) {\r\n  // Memoize accessor calls\r\n  const memoizedAccessor = memo(\r\n    () => [data],\r\n    (deps) =>\r\n      deps[0]\r\n        .flatMap(column.accessor)\r\n        .filter(\r\n          (v): v is NonNullable<TVal> => v !== undefined && v !== null,\r\n        ) as ElementType<NonNullable<TVal>>[],\r\n    { key: `accessor-${column.id}` },\r\n  )\r\n\r\n  const raw = memoizedAccessor()\r\n\r\n  if (!isAnyOf(column.type, ['option', 'multiOption'])) {\r\n    return raw\r\n  }\r\n\r\n  if (column.options) {\r\n    return raw\r\n      .map((v) => column.options?.find((o) => o.value === v)?.value)\r\n      .filter((v) => v !== undefined && v !== null)\r\n  }\r\n\r\n  if (column.transformOptionFn) {\r\n    const memoizedTransform = memo(\r\n      () => [raw],\r\n      (deps) =>\r\n        deps[0].map(\r\n          (v) => column.transformOptionFn!(v) as ElementType<NonNullable<TVal>>,\r\n        ),\r\n      { key: `transform-values-${column.id}` },\r\n    )\r\n    return memoizedTransform()\r\n  }\r\n\r\n  if (isColumnOptionArray(raw)) {\r\n    return raw\r\n  }\r\n\r\n  throw new Error(\r\n    `[data-table-filter] [${column.id}] Either provide static options, a transformOptionFn, or ensure the column data conforms to ColumnOption type`,\r\n  )\r\n}\r\n\r\nexport function getFacetedUniqueValues<\r\n  TData,\r\n  TType extends ColumnDataType,\r\n  TVal,\r\n>(\r\n  column: ColumnConfig<TData, TType, TVal>,\r\n  values: string[] | ColumnOption[],\r\n  strategy: FilterStrategy,\r\n): Map<string, number> | undefined {\r\n  if (!isAnyOf(column.type, ['option', 'multiOption'])) {\r\n    console.warn(\r\n      'Faceted unique values can only be retrieved for option and multiOption columns',\r\n    )\r\n    return new Map<string, number>()\r\n  }\r\n\r\n  if (strategy === 'server') {\r\n    return column.facetedOptions\r\n  }\r\n\r\n  const acc = new Map<string, number>()\r\n\r\n  if (isColumnOptionArray(values)) {\r\n    for (const option of values) {\r\n      const curr = acc.get(option.value) ?? 0\r\n      acc.set(option.value, curr + 1)\r\n    }\r\n  } else {\r\n    for (const option of values) {\r\n      const curr = acc.get(option as string) ?? 0\r\n      acc.set(option as string, curr + 1)\r\n    }\r\n  }\r\n\r\n  return acc\r\n}\r\n\r\nexport function getFacetedMinMaxValues<\r\n  TData,\r\n  TType extends ColumnDataType,\r\n  TVal,\r\n>(column: ColumnConfig<TData, TType, TVal>, data: TData[]): number[] {\r\n  if (column.type !== 'number') return [0, 0] // Only applicable to number columns\r\n\r\n  const values = data\r\n    .flatMap((row) => column.accessor(row) as Nullable<number>)\r\n    .filter((v): v is number => typeof v === 'number' && !Number.isNaN(v))\r\n\r\n  if (values.length === 0) {\r\n    return [column.min ?? 0, column.max ?? 100] // Fallback to config or reasonable defaults\r\n  }\r\n\r\n  const min = Math.min(...values)\r\n  const max = Math.max(...values)\r\n\r\n  // Apply config overrides if provided\r\n  return [\r\n    column.min !== undefined ? Math.max(min, column.min) : min,\r\n    column.max !== undefined ? Math.min(max, column.max) : max,\r\n  ]\r\n}\r\n\r\nexport function createColumns<TData>(\r\n  data: TData[],\r\n  columnConfigs: ReadonlyArray<ColumnConfig<TData, any, any, any>>,\r\n  strategy: FilterStrategy,\r\n): Column<TData>[] {\r\n  return columnConfigs.map((columnConfig) => {\r\n    const getOptions: () => ColumnOption[] = memo(\r\n      () => [data, strategy, columnConfig.options],\r\n      ([data, strategy]) =>\r\n        getColumnOptions(columnConfig, data as any, strategy as any),\r\n      { key: `options-${columnConfig.id}` },\r\n    )\r\n\r\n    const getValues: () => ElementType<NonNullable<any>>[] = memo(\r\n      () => [data, strategy],\r\n      () => (strategy === 'client' ? getColumnValues(columnConfig, data) : []),\r\n      { key: `values-${columnConfig.id}` },\r\n    )\r\n\r\n    const getUniqueValues: () => Map<string, number> | undefined = memo(\r\n      () => [getValues(), strategy],\r\n      ([values, strategy]) =>\r\n        getFacetedUniqueValues(columnConfig, values as any, strategy as any),\r\n      { key: `faceted-${columnConfig.id}` },\r\n    )\r\n\r\n    const getMinMaxValues: () => number[] = memo(\r\n      () => [data, strategy],\r\n      () =>\r\n        strategy === 'client' ? getFacetedMinMaxValues(columnConfig, data) : [],\r\n      { key: `minmax-${columnConfig.id}` },\r\n    )\r\n\r\n    // Create the Column instance\r\n    const column: Column<TData> = {\r\n      ...columnConfig,\r\n      getOptions,\r\n      getValues,\r\n      getFacetedUniqueValues: getUniqueValues,\r\n      getFacetedMinMaxValues: getMinMaxValues,\r\n      // Prefetch methods will be added below\r\n      prefetchOptions: async () => {}, // Placeholder, defined below\r\n      prefetchValues: async () => {},\r\n      prefetchFacetedUniqueValues: async () => {},\r\n      _prefetchedOptionsCache: null, // Initialize private cache\r\n      _prefetchedValuesCache: null,\r\n      _prefetchedFacetedCache: null,\r\n    }\r\n\r\n    if (strategy === 'client') {\r\n      // Define prefetch methods with access to the column instance\r\n      column.prefetchOptions = async (): Promise<void> => {\r\n        if (!column._prefetchedOptionsCache) {\r\n          await new Promise((resolve) =>\r\n            setTimeout(() => {\r\n              const options = getOptions()\r\n              column._prefetchedOptionsCache = options\r\n              // console.log(`Prefetched options for ${columnConfig.id}`)\r\n              resolve(undefined)\r\n            }, 0),\r\n          )\r\n        }\r\n      }\r\n\r\n      column.prefetchValues = async (): Promise<void> => {\r\n        if (!column._prefetchedValuesCache) {\r\n          await new Promise((resolve) =>\r\n            setTimeout(() => {\r\n              const values = getValues()\r\n              column._prefetchedValuesCache = values\r\n              // console.log(`Prefetched values for ${columnConfig.id}`)\r\n              resolve(undefined)\r\n            }, 0),\r\n          )\r\n        }\r\n      }\r\n\r\n      column.prefetchFacetedUniqueValues = async (): Promise<void> => {\r\n        if (!column._prefetchedFacetedCache) {\r\n          await new Promise((resolve) =>\r\n            setTimeout(() => {\r\n              const facetedMap = getUniqueValues()\r\n              column._prefetchedFacetedCache = facetedMap ?? null\r\n              // console.log(\r\n              //   `Prefetched faceted unique values for ${columnConfig.id}`,\r\n              // )\r\n              resolve(undefined)\r\n            }, 0),\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    return column\r\n  })\r\n}\r\n",
=======
      "path": "registry/data-table-filter/core/filters.ts",
      "content": "import { isAnyOf, uniq } from '../lib/array'\nimport { isColumnOptionArray } from '../lib/helpers'\nimport { memo } from '../lib/memo'\nimport type {\n  Column,\n  ColumnConfig,\n  ColumnDataType,\n  ColumnOption,\n  ElementType,\n  FilterStrategy,\n  Nullable,\n  TAccessorFn,\n  TOrderFn,\n  TTransformOptionFn,\n} from './types'\n\nclass ColumnConfigBuilder<\n  TData,\n  TType extends ColumnDataType = any,\n  TVal = unknown,\n  TId extends string = string, // Add TId generic\n> {\n  private config: Partial<ColumnConfig<TData, TType, TVal, TId>>\n\n  constructor(type: TType) {\n    this.config = { type } as Partial<ColumnConfig<TData, TType, TVal, TId>>\n  }\n\n  private clone(): ColumnConfigBuilder<TData, TType, TVal, TId> {\n    const newInstance = new ColumnConfigBuilder<TData, TType, TVal, TId>(\n      this.config.type as TType,\n    )\n    newInstance.config = { ...this.config }\n    return newInstance\n  }\n\n  id<TNewId extends string>(\n    value: TNewId,\n  ): ColumnConfigBuilder<TData, TType, TVal, TNewId> {\n    const newInstance = this.clone() as any // We'll refine this\n    newInstance.config.id = value\n    return newInstance as ColumnConfigBuilder<TData, TType, TVal, TNewId>\n  }\n\n  accessor<TNewVal>(\n    accessor: TAccessorFn<TData, TNewVal>,\n  ): ColumnConfigBuilder<TData, TType, TNewVal, TId> {\n    const newInstance = this.clone() as any\n    newInstance.config.accessor = accessor\n    return newInstance as ColumnConfigBuilder<TData, TType, TNewVal, TId>\n  }\n\n  displayName(value: string): ColumnConfigBuilder<TData, TType, TVal, TId> {\n    const newInstance = this.clone()\n    newInstance.config.displayName = value\n    return newInstance\n  }\n\n  icon(value: any): ColumnConfigBuilder<TData, TType, TVal, TId> {\n    const newInstance = this.clone()\n    newInstance.config.icon = value\n    return newInstance\n  }\n\n  min(\n    value: number,\n  ): ColumnConfigBuilder<\n    TData,\n    TType extends 'number' ? TType : never,\n    TVal,\n    TId\n  > {\n    if (this.config.type !== 'number') {\n      throw new Error('min() is only applicable to number columns')\n    }\n    const newInstance = this.clone() as any\n    newInstance.config.min = value\n    return newInstance\n  }\n\n  max(\n    value: number,\n  ): ColumnConfigBuilder<\n    TData,\n    TType extends 'number' ? TType : never,\n    TVal,\n    TId\n  > {\n    if (this.config.type !== 'number') {\n      throw new Error('max() is only applicable to number columns')\n    }\n    const newInstance = this.clone() as any\n    newInstance.config.max = value\n    return newInstance\n  }\n\n  options(\n    value: ColumnOption[],\n  ): ColumnConfigBuilder<\n    TData,\n    TType extends 'option' | 'multiOption' ? TType : never,\n    TVal,\n    TId\n  > {\n    if (!isAnyOf(this.config.type, ['option', 'multiOption'])) {\n      throw new Error(\n        'options() is only applicable to option or multiOption columns',\n      )\n    }\n    const newInstance = this.clone() as any\n    newInstance.config.options = value\n    return newInstance\n  }\n\n  transformOptionFn(\n    fn: TTransformOptionFn<TVal>,\n  ): ColumnConfigBuilder<\n    TData,\n    TType extends 'option' | 'multiOption' ? TType : never,\n    TVal,\n    TId\n  > {\n    if (!isAnyOf(this.config.type, ['option', 'multiOption'])) {\n      throw new Error(\n        'transformOptionFn() is only applicable to option or multiOption columns',\n      )\n    }\n    const newInstance = this.clone() as any\n    newInstance.config.transformOptionFn = fn\n    return newInstance\n  }\n\n  orderFn(\n    fn: TOrderFn<TVal>,\n  ): ColumnConfigBuilder<\n    TData,\n    TType extends 'option' | 'multiOption' ? TType : never,\n    TVal,\n    TId\n  > {\n    if (!isAnyOf(this.config.type, ['option', 'multiOption'])) {\n      throw new Error(\n        'orderFn() is only applicable to option or multiOption columns',\n      )\n    }\n    const newInstance = this.clone() as any\n    newInstance.config.orderFn = fn\n    return newInstance\n  }\n\n  build(): ColumnConfig<TData, TType, TVal, TId> {\n    if (!this.config.id) throw new Error('id is required')\n    if (!this.config.accessor) throw new Error('accessor is required')\n    if (!this.config.displayName) throw new Error('displayName is required')\n    if (!this.config.icon) throw new Error('icon is required')\n    return this.config as ColumnConfig<TData, TType, TVal, TId>\n  }\n}\n\n// Update the helper interface\ninterface FluentColumnConfigHelper<TData> {\n  text: () => ColumnConfigBuilder<TData, 'text', string>\n  number: () => ColumnConfigBuilder<TData, 'number', number>\n  date: () => ColumnConfigBuilder<TData, 'date', Date>\n  option: () => ColumnConfigBuilder<TData, 'option', string>\n  multiOption: () => ColumnConfigBuilder<TData, 'multiOption', string[]>\n}\n\n// Factory function remains mostly the same\nexport function createColumnConfigHelper<\n  TData,\n>(): FluentColumnConfigHelper<TData> {\n  return {\n    text: () => new ColumnConfigBuilder<TData, 'text', string>('text'),\n    number: () => new ColumnConfigBuilder<TData, 'number', number>('number'),\n    date: () => new ColumnConfigBuilder<TData, 'date', Date>('date'),\n    option: () => new ColumnConfigBuilder<TData, 'option', string>('option'),\n    multiOption: () =>\n      new ColumnConfigBuilder<TData, 'multiOption', string[]>('multiOption'),\n  }\n}\n\nexport function getColumnOptions<TData, TType extends ColumnDataType, TVal>(\n  column: ColumnConfig<TData, TType, TVal>,\n  data: TData[],\n  strategy: FilterStrategy,\n): ColumnOption[] {\n  if (!isAnyOf(column.type, ['option', 'multiOption'])) {\n    console.warn(\n      'Column options can only be retrieved for option and multiOption columns',\n    )\n    return []\n  }\n\n  if (strategy === 'server' && !column.options) {\n    throw new Error('column options are required for server-side filtering')\n  }\n\n  if (column.options) {\n    return column.options\n  }\n\n  const filtered = data\n    .flatMap(column.accessor)\n    .filter((v): v is NonNullable<TVal> => v !== undefined && v !== null)\n\n  let models = uniq(filtered)\n\n  if (column.orderFn) {\n    models = models.sort((m1, m2) =>\n      column.orderFn!(\n        m1 as ElementType<NonNullable<TVal>>,\n        m2 as ElementType<NonNullable<TVal>>,\n      ),\n    )\n  }\n\n  if (column.transformOptionFn) {\n    // Memoize transformOptionFn calls\n    const memoizedTransform = memo(\n      () => [models],\n      (deps) =>\n        deps[0].map((m) =>\n          column.transformOptionFn!(m as ElementType<NonNullable<TVal>>),\n        ),\n      { key: `transform-${column.id}` },\n    )\n    return memoizedTransform()\n  }\n\n  if (isColumnOptionArray(models)) return models\n\n  throw new Error(\n    `[data-table-filter] [${column.id}] Either provide static options, a transformOptionFn, or ensure the column data conforms to ColumnOption type`,\n  )\n}\n\nexport function getColumnValues<TData, TType extends ColumnDataType, TVal>(\n  column: ColumnConfig<TData, TType, TVal>,\n  data: TData[],\n) {\n  // Memoize accessor calls\n  const memoizedAccessor = memo(\n    () => [data],\n    (deps) =>\n      deps[0]\n        .flatMap(column.accessor)\n        .filter(\n          (v): v is NonNullable<TVal> => v !== undefined && v !== null,\n        ) as ElementType<NonNullable<TVal>>[],\n    { key: `accessor-${column.id}` },\n  )\n\n  const raw = memoizedAccessor()\n\n  if (!isAnyOf(column.type, ['option', 'multiOption'])) {\n    return raw\n  }\n\n  if (column.options) {\n    return raw\n      .map((v) => column.options?.find((o) => o.value === v)?.value)\n      .filter((v) => v !== undefined && v !== null)\n  }\n\n  if (column.transformOptionFn) {\n    const memoizedTransform = memo(\n      () => [raw],\n      (deps) =>\n        deps[0].map(\n          (v) => column.transformOptionFn!(v) as ElementType<NonNullable<TVal>>,\n        ),\n      { key: `transform-values-${column.id}` },\n    )\n    return memoizedTransform()\n  }\n\n  if (isColumnOptionArray(raw)) {\n    return raw\n  }\n\n  throw new Error(\n    `[data-table-filter] [${column.id}] Either provide static options, a transformOptionFn, or ensure the column data conforms to ColumnOption type`,\n  )\n}\n\nexport function getFacetedUniqueValues<\n  TData,\n  TType extends ColumnDataType,\n  TVal,\n>(\n  column: ColumnConfig<TData, TType, TVal>,\n  values: string[] | ColumnOption[],\n  strategy: FilterStrategy,\n): Map<string, number> | undefined {\n  if (!isAnyOf(column.type, ['option', 'multiOption'])) {\n    console.warn(\n      'Faceted unique values can only be retrieved for option and multiOption columns',\n    )\n    return new Map<string, number>()\n  }\n\n  if (strategy === 'server') {\n    return column.facetedOptions\n  }\n\n  const acc = new Map<string, number>()\n\n  if (isColumnOptionArray(values)) {\n    for (const option of values) {\n      const curr = acc.get(option.value) ?? 0\n      acc.set(option.value, curr + 1)\n    }\n  } else {\n    for (const option of values) {\n      const curr = acc.get(option as string) ?? 0\n      acc.set(option as string, curr + 1)\n    }\n  }\n\n  return acc\n}\n\nexport function getFacetedMinMaxValues<\n  TData,\n  TType extends ColumnDataType,\n  TVal,\n>(column: ColumnConfig<TData, TType, TVal>, data: TData[]): number[] {\n  if (column.type !== 'number') return [0, 0] // Only applicable to number columns\n\n  const values = data\n    .flatMap((row) => column.accessor(row) as Nullable<number>)\n    .filter((v): v is number => typeof v === 'number' && !Number.isNaN(v))\n\n  if (values.length === 0) {\n    return [column.min ?? 0, column.max ?? 100] // Fallback to config or reasonable defaults\n  }\n\n  const min = Math.min(...values)\n  const max = Math.max(...values)\n\n  // Apply config overrides if provided\n  return [\n    column.min !== undefined ? Math.max(min, column.min) : min,\n    column.max !== undefined ? Math.min(max, column.max) : max,\n  ]\n}\n\nexport function createColumns<TData>(\n  data: TData[],\n  columnConfigs: ReadonlyArray<ColumnConfig<TData, any, any, any>>,\n  strategy: FilterStrategy,\n): Column<TData>[] {\n  return columnConfigs.map((columnConfig) => {\n    const getOptions: () => ColumnOption[] = memo(\n      () => [data, strategy, columnConfig.options],\n      ([data, strategy]) =>\n        getColumnOptions(columnConfig, data as any, strategy as any),\n      { key: `options-${columnConfig.id}` },\n    )\n\n    const getValues: () => ElementType<NonNullable<any>>[] = memo(\n      () => [data, strategy],\n      () => (strategy === 'client' ? getColumnValues(columnConfig, data) : []),\n      { key: `values-${columnConfig.id}` },\n    )\n\n    const getUniqueValues: () => Map<string, number> | undefined = memo(\n      () => [getValues(), strategy],\n      ([values, strategy]) =>\n        getFacetedUniqueValues(columnConfig, values as any, strategy as any),\n      { key: `faceted-${columnConfig.id}` },\n    )\n\n    const getMinMaxValues: () => number[] = memo(\n      () => [data, strategy],\n      () =>\n        strategy === 'client' ? getFacetedMinMaxValues(columnConfig, data) : [],\n      { key: `minmax-${columnConfig.id}` },\n    )\n\n    // Create the Column instance\n    const column: Column<TData> = {\n      ...columnConfig,\n      getOptions,\n      getValues,\n      getFacetedUniqueValues: getUniqueValues,\n      getFacetedMinMaxValues: getMinMaxValues,\n      // Prefetch methods will be added below\n      prefetchOptions: async () => {}, // Placeholder, defined below\n      prefetchValues: async () => {},\n      prefetchFacetedUniqueValues: async () => {},\n      _prefetchedOptionsCache: null, // Initialize private cache\n      _prefetchedValuesCache: null,\n      _prefetchedFacetedCache: null,\n    }\n\n    if (strategy === 'client') {\n      // Define prefetch methods with access to the column instance\n      column.prefetchOptions = async (): Promise<void> => {\n        if (!column._prefetchedOptionsCache) {\n          await new Promise((resolve) =>\n            setTimeout(() => {\n              const options = getOptions()\n              column._prefetchedOptionsCache = options\n              // console.log(`Prefetched options for ${columnConfig.id}`)\n              resolve(undefined)\n            }, 0),\n          )\n        }\n      }\n\n      column.prefetchValues = async (): Promise<void> => {\n        if (!column._prefetchedValuesCache) {\n          await new Promise((resolve) =>\n            setTimeout(() => {\n              const values = getValues()\n              column._prefetchedValuesCache = values\n              // console.log(`Prefetched values for ${columnConfig.id}`)\n              resolve(undefined)\n            }, 0),\n          )\n        }\n      }\n\n      column.prefetchFacetedUniqueValues = async (): Promise<void> => {\n        if (!column._prefetchedFacetedCache) {\n          await new Promise((resolve) =>\n            setTimeout(() => {\n              const facetedMap = getUniqueValues()\n              column._prefetchedFacetedCache = facetedMap ?? null\n              // console.log(\n              //   `Prefetched faceted unique values for ${columnConfig.id}`,\n              // )\n              resolve(undefined)\n            }, 0),\n          )\n        }\n      }\n    }\n\n    return column\n  })\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/core/filters.ts"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/core/operators.ts",
      "content": "import { Locale, t } from '../lib/i18n'\r\nimport type {\r\n  ColumnDataType,\r\n  FilterDetails,\r\n  FilterOperatorTarget,\r\n  FilterOperators,\r\n  FilterTypeOperatorDetails,\r\n  FilterValues,\r\n} from './types'\r\n\r\nexport const DEFAULT_OPERATORS: Record<\r\n  ColumnDataType,\r\n  Record<FilterOperatorTarget, FilterOperators[ColumnDataType]>\r\n> = {\r\n  text: {\r\n    single: 'contains',\r\n    multiple: 'contains',\r\n  },\r\n  number: {\r\n    single: 'is',\r\n    multiple: 'is between',\r\n  },\r\n  date: {\r\n    single: 'is',\r\n    multiple: 'is between',\r\n  },\r\n  option: {\r\n    single: 'is',\r\n    multiple: 'is any of',\r\n  },\r\n  multiOption: {\r\n    single: 'include',\r\n    multiple: 'include any of',\r\n  },\r\n}\r\n\r\n/* Details for all the filter operators for option data type */\r\nexport function getOptionFilterDetails(locale: Locale) {\r\n  return {\r\n    is: {\r\n      label: t('filters.option.is', locale),\r\n      value: 'is',\r\n      target: 'single',\r\n      singularOf: 'is any of',\r\n      relativeOf: 'is not',\r\n      isNegated: false,\r\n      negation: 'is not',\r\n    },\r\n    'is not': {\r\n      label: t('filters.option.isNot', locale),\r\n      value: 'is not',\r\n      target: 'single',\r\n      singularOf: 'is none of',\r\n      relativeOf: 'is',\r\n      isNegated: true,\r\n      negationOf: 'is',\r\n    },\r\n    'is any of': {\r\n      label: t('filters.option.isAnyOf', locale),\r\n      value: 'is any of',\r\n      target: 'multiple',\r\n      pluralOf: 'is',\r\n      relativeOf: 'is none of',\r\n      isNegated: false,\r\n      negation: 'is none of',\r\n    },\r\n    'is none of': {\r\n      label: t('filters.option.isNoneOf', locale),\r\n      value: 'is none of',\r\n      target: 'multiple',\r\n      pluralOf: 'is not',\r\n      relativeOf: 'is any of',\r\n      isNegated: true,\r\n      negationOf: 'is any of',\r\n    },\r\n  } as const satisfies FilterDetails<'option'>\r\n}\r\n\r\n/* Details for all the filter operators for multi-option data type */\r\nexport function getMultiOptionFilterDetails(locale: Locale) {\r\n  return {\r\n    include: {\r\n      label: t('filters.multiOption.include', locale),\r\n      value: 'include',\r\n      target: 'single',\r\n      singularOf: 'include any of',\r\n      relativeOf: 'exclude',\r\n      isNegated: false,\r\n      negation: 'exclude',\r\n    },\r\n    exclude: {\r\n      label: t('filters.multiOption.exclude', locale),\r\n      value: 'exclude',\r\n      target: 'single',\r\n      singularOf: 'exclude if any of',\r\n      relativeOf: 'include',\r\n      isNegated: true,\r\n      negationOf: 'include',\r\n    },\r\n    'include any of': {\r\n      label: t('filters.multiOption.includeAnyOf', locale),\r\n      value: 'include any of',\r\n      target: 'multiple',\r\n      pluralOf: 'include',\r\n      relativeOf: ['exclude if all', 'include all of', 'exclude if any of'],\r\n      isNegated: false,\r\n      negation: 'exclude if all',\r\n    },\r\n    'exclude if all': {\r\n      label: t('filters.multiOption.excludeIfAll', locale),\r\n      value: 'exclude if all',\r\n      target: 'multiple',\r\n      pluralOf: 'exclude',\r\n      relativeOf: ['include any of', 'include all of', 'exclude if any of'],\r\n      isNegated: true,\r\n      negationOf: 'include any of',\r\n    },\r\n    'include all of': {\r\n      label: t('filters.multiOption.includeAllOf', locale),\r\n      value: 'include all of',\r\n      target: 'multiple',\r\n      pluralOf: 'include',\r\n      relativeOf: ['include any of', 'exclude if all', 'exclude if any of'],\r\n      isNegated: false,\r\n      negation: 'exclude if any of',\r\n    },\r\n    'exclude if any of': {\r\n      label: t('filters.multiOption.excludeIfAnyOf', locale),\r\n      value: 'exclude if any of',\r\n      target: 'multiple',\r\n      pluralOf: 'exclude',\r\n      relativeOf: ['include any of', 'exclude if all', 'include all of'],\r\n      isNegated: true,\r\n      negationOf: 'include all of',\r\n    },\r\n  } as const satisfies FilterDetails<'multiOption'>\r\n}\r\n\r\n/* Details for all the filter operators for date data type */\r\nexport function getDateFilterDetails(locale: Locale) {\r\n  return {\r\n    is: {\r\n      label: t('filters.date.is', locale),\r\n      value: 'is',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: 'is after',\r\n      isNegated: false,\r\n      negation: 'is before',\r\n    },\r\n    'is not': {\r\n      label: t('filters.date.isNot', locale),\r\n      value: 'is not',\r\n      target: 'single',\r\n      singularOf: 'is not between',\r\n      relativeOf: ['is', 'is before', 'is on or after', 'is after', 'is on or before'],\r\n      isNegated: true,\r\n      negationOf: 'is',\r\n    },\r\n    'is before': {\r\n      label: t('filters.date.isBefore', locale),\r\n      value: 'is before',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is', 'is not', 'is on or after', 'is after', 'is on or before'],\r\n      isNegated: false,\r\n      negation: 'is on or after',\r\n    },\r\n    'is on or after': {\r\n      label: t('filters.date.isOnOrAfter', locale),\r\n      value: 'is on or after',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is', 'is not', 'is before', 'is after', 'is on or before'],\r\n      isNegated: false,\r\n      negation: 'is before',\r\n    },\r\n    'is after': {\r\n      label: t('filters.date.isAfter', locale),\r\n      value: 'is after',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is', 'is not', 'is before', 'is on or after', 'is on or before'],\r\n      isNegated: false,\r\n      negation: 'is on or before',\r\n    },\r\n    'is on or before': {\r\n      label: t('filters.date.isOnOrBefore', locale),\r\n      value: 'is on or before',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is', 'is not', 'is after', 'is on or after', 'is before'],\r\n      isNegated: false,\r\n      negation: 'is after',\r\n    },\r\n    'is between': {\r\n      label: t('filters.date.isBetween', locale),\r\n      value: 'is between',\r\n      target: 'multiple',\r\n      pluralOf: 'is',\r\n      relativeOf: 'is not between',\r\n      isNegated: false,\r\n      negation: 'is not between',\r\n    },\r\n    'is not between': {\r\n      label: t('filters.date.isNotBetween', locale),\r\n      value: 'is not between',\r\n      target: 'multiple',\r\n      pluralOf: 'is not',\r\n      relativeOf: 'is between',\r\n      isNegated: true,\r\n      negationOf: 'is between',\r\n    },\r\n  } as const satisfies FilterDetails<'date'>\r\n}\r\n\r\n\r\n/* Details for all the filter operators for text data type */\r\nexport function getTextFilterDetails(locale: Locale) {\r\n  return {\r\n    contains: {\r\n      label: t('filters.text.contains', locale),\r\n      value: 'contains',\r\n      target: 'single',\r\n      relativeOf: 'does not contain',\r\n      isNegated: false,\r\n      negation: 'does not contain',\r\n    },\r\n    'does not contain': {\r\n      label: t('filters.text.doesNotContain', locale),\r\n      value: 'does not contain',\r\n      target: 'single',\r\n      relativeOf: 'contains',\r\n      isNegated: true,\r\n      negationOf: 'contains',\r\n    },\r\n  } as const satisfies FilterDetails<'text'>\r\n}\r\n\r\n\r\n/* Details for all the filter operators for number data type */\r\nexport function getNumberFilterDetails(locale: Locale) {\r\n  return {\r\n    is: {\r\n      label: t('filters.number.is', locale),\r\n      value: 'is',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is not', 'is greater than', 'is less than or equal to', 'is less than', 'is greater than or equal to'],\r\n      isNegated: false,\r\n      negation: 'is not',\r\n    },\r\n    'is not': {\r\n      label: t('filters.number.isNot', locale),\r\n      value: 'is not',\r\n      target: 'single',\r\n      singularOf: 'is not between',\r\n      relativeOf: ['is', 'is greater than', 'is less than or equal to', 'is less than', 'is greater than or equal to'],\r\n      isNegated: true,\r\n      negationOf: 'is',\r\n    },\r\n    'is greater than': {\r\n      label: t('filters.number.greaterThan', locale),\r\n      value: 'is greater than',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is', 'is not', 'is less than or equal to', 'is less than', 'is greater than or equal to'],\r\n      isNegated: false,\r\n      negation: 'is less than or equal to',\r\n    },\r\n    'is greater than or equal to': {\r\n      label: t('filters.number.greaterThanOrEqual', locale),\r\n      value: 'is greater than or equal to',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is', 'is not', 'is greater than', 'is less than or equal to', 'is less than'],\r\n      isNegated: false,\r\n      negation: 'is less than or equal to',\r\n    },\r\n    'is less than': {\r\n      label: t('filters.number.lessThan', locale),\r\n      value: 'is less than',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is', 'is not', 'is greater than', 'is less than or equal to', 'is greater than or equal to'],\r\n      isNegated: false,\r\n      negation: 'is greater than',\r\n    },\r\n    'is less than or equal to': {\r\n      label: t('filters.number.lessThanOrEqual', locale),\r\n      value: 'is less than or equal to',\r\n      target: 'single',\r\n      singularOf: 'is between',\r\n      relativeOf: ['is', 'is not', 'is greater than', 'is less than', 'is greater than or equal to'],\r\n      isNegated: false,\r\n      negation: 'is greater than or equal to',\r\n    },\r\n    'is between': {\r\n      label: t('filters.number.isBetween', locale),\r\n      value: 'is between',\r\n      target: 'multiple',\r\n      pluralOf: 'is',\r\n      relativeOf: 'is not between',\r\n      isNegated: false,\r\n      negation: 'is not between',\r\n    },\r\n    'is not between': {\r\n      label: t('filters.number.isNotBetween', locale),\r\n      value: 'is not between',\r\n      target: 'multiple',\r\n      pluralOf: 'is not',\r\n      relativeOf: 'is between',\r\n      isNegated: true,\r\n      negationOf: 'is between',\r\n    },\r\n  } as const satisfies FilterDetails<'number'>\r\n}\r\n\r\n\r\nexport function getFilterTypeOperatorDetails(locale: Locale): FilterTypeOperatorDetails {\r\n  return {\r\n    text: getTextFilterDetails(locale),\r\n    number: getNumberFilterDetails(locale),\r\n    date: getDateFilterDetails(locale),\r\n    option: getOptionFilterDetails(locale),\r\n    multiOption: getMultiOptionFilterDetails(locale),\r\n  }\r\n}\r\n\r\n/*\r\n *\r\n * Determines the new operator for a filter based on the current operator, old and new filter values.\r\n *\r\n * This handles cases where the filter values have transitioned from a single value to multiple values (or vice versa),\r\n * and the current operator needs to be transitioned to its plural form (or singular form).\r\n *\r\n * For example, if the current operator is 'is', and the new filter values have a length of 2, the\r\n * new operator would be 'is any of'.\r\n *\r\n */\r\nexport function determineNewOperator<TType extends ColumnDataType>(\r\n  type: TType,\r\n  oldVals: FilterValues<TType>,\r\n  nextVals: FilterValues<TType>,\r\n  currentOperator: FilterOperators[TType],\r\n  locale: Locale,\r\n): FilterOperators[TType] {\r\n  const a =\r\n    Array.isArray(oldVals) && Array.isArray(oldVals[0])\r\n      ? oldVals[0].length\r\n      : oldVals.length\r\n  const b =\r\n    Array.isArray(nextVals) && Array.isArray(nextVals[0])\r\n      ? nextVals[0].length\r\n      : nextVals.length\r\n\r\n  // If filter size has not transitioned from single to multiple (or vice versa)\r\n  // or is unchanged, return the current operator.\r\n  if (a === b || (a >= 2 && b >= 2) || (a <= 1 && b <= 1))\r\n    return currentOperator\r\n\r\n  const opDetails = getFilterTypeOperatorDetails(locale)[type][currentOperator]\r\n\r\n  // Handle transition from single to multiple filter values.\r\n  if (a < b && b >= 2) return opDetails.singularOf ?? currentOperator\r\n  // Handle transition from multiple to single filter values.\r\n  if (a > b && b <= 1) return opDetails.pluralOf ?? currentOperator\r\n  return currentOperator\r\n}\r\n",
=======
      "path": "registry/data-table-filter/core/operators.ts",
      "content": "import type {\n  ColumnDataType,\n  FilterDetails,\n  FilterOperatorTarget,\n  FilterOperators,\n  FilterTypeOperatorDetails,\n  FilterValues,\n} from './types'\n\nexport const DEFAULT_OPERATORS: Record<\n  ColumnDataType,\n  Record<FilterOperatorTarget, FilterOperators[ColumnDataType]>\n> = {\n  text: {\n    single: 'contains',\n    multiple: 'contains',\n  },\n  number: {\n    single: 'is',\n    multiple: 'is between',\n  },\n  date: {\n    single: 'is',\n    multiple: 'is between',\n  },\n  option: {\n    single: 'is',\n    multiple: 'is any of',\n  },\n  multiOption: {\n    single: 'include',\n    multiple: 'include any of',\n  },\n}\n\n/* Details for all the filter operators for option data type */\nexport const optionFilterDetails = {\n  is: {\n    label: 'is',\n    value: 'is',\n    target: 'single',\n    singularOf: 'is any of',\n    relativeOf: 'is not',\n    isNegated: false,\n    negation: 'is not',\n  },\n  'is not': {\n    label: 'is not',\n    value: 'is not',\n    target: 'single',\n    singularOf: 'is none of',\n    relativeOf: 'is',\n    isNegated: true,\n    negationOf: 'is',\n  },\n  'is any of': {\n    label: 'is any of',\n    value: 'is any of',\n    target: 'multiple',\n    pluralOf: 'is',\n    relativeOf: 'is none of',\n    isNegated: false,\n    negation: 'is none of',\n  },\n  'is none of': {\n    label: 'is none of',\n    value: 'is none of',\n    target: 'multiple',\n    pluralOf: 'is not',\n    relativeOf: 'is any of',\n    isNegated: true,\n    negationOf: 'is any of',\n  },\n} as const satisfies FilterDetails<'option'>\n\n/* Details for all the filter operators for multi-option data type */\nexport const multiOptionFilterDetails = {\n  include: {\n    label: 'include',\n    value: 'include',\n    target: 'single',\n    singularOf: 'include any of',\n    relativeOf: 'exclude',\n    isNegated: false,\n    negation: 'exclude',\n  },\n  exclude: {\n    label: 'exclude',\n    value: 'exclude',\n    target: 'single',\n    singularOf: 'exclude if any of',\n    relativeOf: 'include',\n    isNegated: true,\n    negationOf: 'include',\n  },\n  'include any of': {\n    label: 'include any of',\n    value: 'include any of',\n    target: 'multiple',\n    pluralOf: 'include',\n    relativeOf: ['exclude if all', 'include all of', 'exclude if any of'],\n    isNegated: false,\n    negation: 'exclude if all',\n  },\n  'exclude if all': {\n    label: 'exclude if all',\n    value: 'exclude if all',\n    target: 'multiple',\n    pluralOf: 'exclude',\n    relativeOf: ['include any of', 'include all of', 'exclude if any of'],\n    isNegated: true,\n    negationOf: 'include any of',\n  },\n  'include all of': {\n    label: 'include all of',\n    value: 'include all of',\n    target: 'multiple',\n    pluralOf: 'include',\n    relativeOf: ['include any of', 'exclude if all', 'exclude if any of'],\n    isNegated: false,\n    negation: 'exclude if any of',\n  },\n  'exclude if any of': {\n    label: 'exclude if any of',\n    value: 'exclude if any of',\n    target: 'multiple',\n    pluralOf: 'exclude',\n    relativeOf: ['include any of', 'exclude if all', 'include all of'],\n    isNegated: true,\n    negationOf: 'include all of',\n  },\n} as const satisfies FilterDetails<'multiOption'>\n\n/* Details for all the filter operators for date data type */\nexport const dateFilterDetails = {\n  is: {\n    label: 'is',\n    value: 'is',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: 'is after',\n    isNegated: false,\n    negation: 'is before',\n  },\n  'is not': {\n    label: 'is not',\n    value: 'is not',\n    target: 'single',\n    singularOf: 'is not between',\n    relativeOf: [\n      'is',\n      'is before',\n      'is on or after',\n      'is after',\n      'is on or before',\n    ],\n    isNegated: true,\n    negationOf: 'is',\n  },\n  'is before': {\n    label: 'is before',\n    value: 'is before',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is',\n      'is not',\n      'is on or after',\n      'is after',\n      'is on or before',\n    ],\n    isNegated: false,\n    negation: 'is on or after',\n  },\n  'is on or after': {\n    label: 'is on or after',\n    value: 'is on or after',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: ['is', 'is not', 'is before', 'is after', 'is on or before'],\n    isNegated: false,\n    negation: 'is before',\n  },\n  'is after': {\n    label: 'is after',\n    value: 'is after',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is',\n      'is not',\n      'is before',\n      'is on or after',\n      'is on or before',\n    ],\n    isNegated: false,\n    negation: 'is on or before',\n  },\n  'is on or before': {\n    label: 'is on or before',\n    value: 'is on or before',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: ['is', 'is not', 'is after', 'is on or after', 'is before'],\n    isNegated: false,\n    negation: 'is after',\n  },\n  'is between': {\n    label: 'is between',\n    value: 'is between',\n    target: 'multiple',\n    pluralOf: 'is',\n    relativeOf: 'is not between',\n    isNegated: false,\n    negation: 'is not between',\n  },\n  'is not between': {\n    label: 'is not between',\n    value: 'is not between',\n    target: 'multiple',\n    pluralOf: 'is not',\n    relativeOf: 'is between',\n    isNegated: true,\n    negationOf: 'is between',\n  },\n} as const satisfies FilterDetails<'date'>\n\n/* Details for all the filter operators for text data type */\nexport const textFilterDetails = {\n  contains: {\n    label: 'contains',\n    value: 'contains',\n    target: 'single',\n    relativeOf: 'does not contain',\n    isNegated: false,\n    negation: 'does not contain',\n  },\n  'does not contain': {\n    label: 'does not contain',\n    value: 'does not contain',\n    target: 'single',\n    relativeOf: 'contains',\n    isNegated: true,\n    negationOf: 'contains',\n  },\n} as const satisfies FilterDetails<'text'>\n\n/* Details for all the filter operators for number data type */\nexport const numberFilterDetails = {\n  is: {\n    label: 'is',\n    value: 'is',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is not',\n      'is greater than',\n      'is less than or equal to',\n      'is less than',\n      'is greater than or equal to',\n    ],\n    isNegated: false,\n    negation: 'is not',\n  },\n  'is not': {\n    label: 'is not',\n    value: 'is not',\n    target: 'single',\n    singularOf: 'is not between',\n    relativeOf: [\n      'is',\n      'is greater than',\n      'is less than or equal to',\n      'is less than',\n      'is greater than or equal to',\n    ],\n    isNegated: true,\n    negationOf: 'is',\n  },\n  'is greater than': {\n    label: '>',\n    value: 'is greater than',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is',\n      'is not',\n      'is less than or equal to',\n      'is less than',\n      'is greater than or equal to',\n    ],\n    isNegated: false,\n    negation: 'is less than or equal to',\n  },\n  'is greater than or equal to': {\n    label: '>=',\n    value: 'is greater than or equal to',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is',\n      'is not',\n      'is greater than',\n      'is less than or equal to',\n      'is less than',\n    ],\n    isNegated: false,\n    negation: 'is less than or equal to',\n  },\n  'is less than': {\n    label: '<',\n    value: 'is less than',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is',\n      'is not',\n      'is greater than',\n      'is less than or equal to',\n      'is greater than or equal to',\n    ],\n    isNegated: false,\n    negation: 'is greater than',\n  },\n  'is less than or equal to': {\n    label: '<=',\n    value: 'is less than or equal to',\n    target: 'single',\n    singularOf: 'is between',\n    relativeOf: [\n      'is',\n      'is not',\n      'is greater than',\n      'is less than',\n      'is greater than or equal to',\n    ],\n    isNegated: false,\n    negation: 'is greater than or equal to',\n  },\n  'is between': {\n    label: 'is between',\n    value: 'is between',\n    target: 'multiple',\n    pluralOf: 'is',\n    relativeOf: 'is not between',\n    isNegated: false,\n    negation: 'is not between',\n  },\n  'is not between': {\n    label: 'is not between',\n    value: 'is not between',\n    target: 'multiple',\n    pluralOf: 'is not',\n    relativeOf: 'is between',\n    isNegated: true,\n    negationOf: 'is between',\n  },\n} as const satisfies FilterDetails<'number'>\n\nexport const filterTypeOperatorDetails: FilterTypeOperatorDetails = {\n  text: textFilterDetails,\n  number: numberFilterDetails,\n  date: dateFilterDetails,\n  option: optionFilterDetails,\n  multiOption: multiOptionFilterDetails,\n}\n\n/*\n *\n * Determines the new operator for a filter based on the current operator, old and new filter values.\n *\n * This handles cases where the filter values have transitioned from a single value to multiple values (or vice versa),\n * and the current operator needs to be transitioned to its plural form (or singular form).\n *\n * For example, if the current operator is 'is', and the new filter values have a length of 2, the\n * new operator would be 'is any of'.\n *\n */\nexport function determineNewOperator<TType extends ColumnDataType>(\n  type: TType,\n  oldVals: FilterValues<TType>,\n  nextVals: FilterValues<TType>,\n  currentOperator: FilterOperators[TType],\n): FilterOperators[TType] {\n  const a =\n    Array.isArray(oldVals) && Array.isArray(oldVals[0])\n      ? oldVals[0].length\n      : oldVals.length\n  const b =\n    Array.isArray(nextVals) && Array.isArray(nextVals[0])\n      ? nextVals[0].length\n      : nextVals.length\n\n  // If filter size has not transitioned from single to multiple (or vice versa)\n  // or is unchanged, return the current operator.\n  if (a === b || (a >= 2 && b >= 2) || (a <= 1 && b <= 1))\n    return currentOperator\n\n  const opDetails = filterTypeOperatorDetails[type][currentOperator]\n\n  // Handle transition from single to multiple filter values.\n  if (a < b && b >= 2) return opDetails.singularOf ?? currentOperator\n  // Handle transition from multiple to single filter values.\n  if (a > b && b <= 1) return opDetails.pluralOf ?? currentOperator\n  return currentOperator\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/core/operators.ts"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/core/types.ts",
      "content": "import type { LucideIcon } from 'lucide-react'\r\nimport { Locale } from '../lib/i18n'\r\n\r\n/*\r\n * # GENERAL NOTES:\r\n *\r\n * ## GENERICS:\r\n *\r\n * TData is the shape of a single row in your data table.\r\n * TVal is the shape of the underlying value for a column.\r\n * TType is the type (kind) of the column.\r\n *\r\n */\r\n\r\nexport type ElementType<T> = T extends (infer U)[] ? U : T\r\n\r\nexport type Nullable<T> = T | null | undefined\r\n\r\n/*\r\n * The model of a column option.\r\n * Used for representing underlying column values of type `option` or `multiOption`.\r\n */\r\nexport interface ColumnOption {\r\n  /* The label to display for the option. */\r\n  label: string\r\n  /* The internal value of the option. */\r\n  value: string\r\n  /* An optional icon to display next to the label. */\r\n  icon?: React.ReactElement | React.ElementType\r\n}\r\n\r\n/*\r\n * Represents the data type (kind) of a column.\r\n */\r\nexport type ColumnDataType =\r\n  /* The column value is a string that should be searchable. */\r\n  | 'text'\r\n  | 'number'\r\n  | 'date'\r\n  /* The column value can be a single value from a list of options. */\r\n  | 'option'\r\n  /* The column value can be zero or more values from a list of options. */\r\n  | 'multiOption'\r\n\r\n/*\r\n * Represents the data type (kind) of option and multi-option columns.\r\n */\r\nexport type OptionBasedColumnDataType = Extract<\r\n  ColumnDataType,\r\n  'option' | 'multiOption'\r\n>\r\n\r\n/*\r\n * Maps a ColumnDataType to it's primitive type (i.e. string, number, etc.).\r\n */\r\nexport type ColumnDataNativeMap = {\r\n  text: string\r\n  number: number\r\n  date: Date\r\n  option: string\r\n  multiOption: string[]\r\n}\r\n\r\n/*\r\n * Represents the value of a column filter.\r\n * Contigent on the filtered column's data type.\r\n */\r\nexport type FilterValues<T extends ColumnDataType> = Array<\r\n  ElementType<ColumnDataNativeMap[T]>\r\n>\r\n\r\n/*\r\n * An accessor function for a column's data.\r\n * Uses the original row data as an argument.\r\n */\r\nexport type TAccessorFn<TData, TVal = unknown> = (data: TData) => TVal\r\n\r\n/*\r\n * Used by `option` and `multiOption` columns.\r\n * Transforms the underlying column value into a valid ColumnOption.\r\n */\r\nexport type TTransformOptionFn<TVal = unknown> = (\r\n  value: ElementType<NonNullable<TVal>>,\r\n) => ColumnOption\r\n\r\n/*\r\n * Used by `option` and `multiOption` columns.\r\n * A custom ordering function when sorting a column's options.\r\n */\r\nexport type TOrderFn<TVal = unknown> = (\r\n  a: ElementType<NonNullable<TVal>>,\r\n  b: ElementType<NonNullable<TVal>>,\r\n) => number\r\n\r\n/*\r\n * The configuration for a column.\r\n */\r\nexport type ColumnConfig<\r\n  TData,\r\n  TType extends ColumnDataType = any,\r\n  TVal = unknown,\r\n  TId extends string = string,\r\n> = {\r\n  id: TId\r\n  accessor: TAccessorFn<TData, TVal>\r\n  displayName: string\r\n  icon: LucideIcon\r\n  type: TType\r\n  options?: TType extends OptionBasedColumnDataType ? ColumnOption[] : never\r\n  facetedOptions?: TType extends OptionBasedColumnDataType\r\n    ? Map<string, number>\r\n    : never\r\n  min?: TType extends 'number' ? number : never\r\n  max?: TType extends 'number' ? number : never\r\n  transformOptionFn?: TType extends OptionBasedColumnDataType\r\n    ? TTransformOptionFn<TVal>\r\n    : never\r\n  orderFn?: TType extends OptionBasedColumnDataType ? TOrderFn<TVal> : never\r\n}\r\n\r\nexport type OptionColumnId<T> = T extends ColumnConfig<\r\n  infer TData,\r\n  'option' | 'multiOption',\r\n  infer TVal,\r\n  infer TId\r\n>\r\n  ? TId\r\n  : never\r\n\r\nexport type OptionColumnIds<\r\n  T extends ReadonlyArray<ColumnConfig<any, any, any, any>>,\r\n> = {\r\n  [K in keyof T]: OptionColumnId<T[K]>\r\n}[number]\r\n\r\n/*\r\n * Describes a helper function for creating column configurations.\r\n */\r\nexport type ColumnConfigHelper<TData> = {\r\n  accessor: <\r\n    TAccessor extends TAccessorFn<TData>,\r\n    TType extends ColumnDataType,\r\n    TVal extends ReturnType<TAccessor>,\r\n  >(\r\n    accessor: TAccessor,\r\n    config?: Omit<ColumnConfig<TData, TType, TVal>, 'accessor'>,\r\n  ) => ColumnConfig<TData, TType, unknown>\r\n}\r\n\r\nexport type DataTableFilterConfig<TData> = {\r\n  data: TData[]\r\n  columns: ColumnConfig<TData>[]\r\n}\r\n\r\nexport type ColumnProperties<TData, TVal> = {\r\n  getOptions: () => ColumnOption[]\r\n  getValues: () => ElementType<NonNullable<TVal>>[]\r\n  getFacetedUniqueValues: () => Map<string, number> | undefined\r\n  getFacetedMinMaxValues: () => number[]\r\n  prefetchOptions: () => Promise<void> // Prefetch options\r\n  prefetchValues: () => Promise<void> // Prefetch values\r\n  prefetchFacetedUniqueValues: () => Promise<void> // Prefetch faceted unique values\r\n}\r\n\r\nexport type ColumnPrivateProperties<TData, TVal> = {\r\n  _prefetchedOptionsCache: ColumnOption[] | null\r\n  _prefetchedValuesCache: ElementType<NonNullable<TVal>>[] | null\r\n  _prefetchedFacetedCache: Map<string, number> | null\r\n}\r\n\r\nexport type Column<\r\n  TData,\r\n  TType extends ColumnDataType = any,\r\n  TVal = unknown,\r\n> = ColumnConfig<TData, TType, TVal> &\r\n  ColumnProperties<TData, TVal> &\r\n  ColumnPrivateProperties<TData, TVal>\r\n\r\n/*\r\n * Describes the available actions on column filters.\r\n * Includes both column-specific and global actions, ultimately acting on the column filters.\r\n */\r\nexport interface DataTableFilterActions {\r\n  addFilterValue: <TData, TType extends OptionBasedColumnDataType>(\r\n    column: Column<TData, TType>,\r\n    values: FilterModel<TType>['values'],\r\n  ) => void\r\n\r\n  removeFilterValue: <TData, TType extends OptionBasedColumnDataType>(\r\n    column: Column<TData, TType>,\r\n    value: FilterModel<TType>['values'],\r\n  ) => void\r\n\r\n  setFilterValue: <TData, TType extends ColumnDataType>(\r\n    column: Column<TData, TType>,\r\n    values: FilterModel<TType>['values'],\r\n  ) => void\r\n\r\n  setFilterOperator: <TType extends ColumnDataType>(\r\n    columnId: string,\r\n    operator: FilterModel<TType>['operator'],\r\n  ) => void\r\n\r\n  removeFilter: (columnId: string) => void\r\n\r\n  removeAllFilters: () => void\r\n}\r\n\r\nexport type FilterStrategy = 'client' | 'server'\r\n\r\n/* Operators for text data */\r\nexport type TextFilterOperator = 'contains' | 'does not contain'\r\n\r\n/* Operators for number data */\r\nexport type NumberFilterOperator =\r\n  | 'is'\r\n  | 'is not'\r\n  | 'is less than'\r\n  | 'is greater than or equal to'\r\n  | 'is greater than'\r\n  | 'is less than or equal to'\r\n  | 'is between'\r\n  | 'is not between'\r\n\r\n/* Operators for date data */\r\nexport type DateFilterOperator =\r\n  | 'is'\r\n  | 'is not'\r\n  | 'is before'\r\n  | 'is on or after'\r\n  | 'is after'\r\n  | 'is on or before'\r\n  | 'is between'\r\n  | 'is not between'\r\n\r\n/* Operators for option data */\r\nexport type OptionFilterOperator = 'is' | 'is not' | 'is any of' | 'is none of'\r\n\r\n/* Operators for multi-option data */\r\nexport type MultiOptionFilterOperator =\r\n  | 'include'\r\n  | 'exclude'\r\n  | 'include any of'\r\n  | 'include all of'\r\n  | 'exclude if any of'\r\n  | 'exclude if all'\r\n\r\n/* Maps filter operators to their respective data types */\r\nexport type FilterOperators = {\r\n  text: TextFilterOperator\r\n  number: NumberFilterOperator\r\n  date: DateFilterOperator\r\n  option: OptionFilterOperator\r\n  multiOption: MultiOptionFilterOperator\r\n}\r\n\r\n/*\r\n *\r\n * FilterValue is a type that represents a filter value for a specific column.\r\n *\r\n * It consists of:\r\n * - Operator: The operator to be used for the filter.\r\n * - Values: An array of values to be used for the filter.\r\n *\r\n */\r\nexport type FilterModel<TType extends ColumnDataType = any> = {\r\n  columnId: string\r\n  operator: FilterOperators[TType]\r\n  values: FilterValues<TType>\r\n}\r\n\r\nexport type FiltersState = Array<FilterModel>\r\n\r\n/*\r\n * FilterDetails is a type that represents the details of all the filter operators for a specific column data type.\r\n */\r\nexport type FilterDetails<T extends ColumnDataType> = {\r\n  [key in FilterOperators[T]]: FilterOperatorDetails<key, T>\r\n}\r\n\r\nexport type FilterOperatorTarget = 'single' | 'multiple'\r\n\r\nexport type FilterOperatorDetailsBase<\r\n  OperatorValue,\r\n  T extends ColumnDataType,\r\n> = {\r\n  /* The operator value. Usually the string representation of the operator. */\r\n  value: OperatorValue\r\n  /* The label for the operator, to show in the UI. */\r\n  label: string\r\n  /* How much data the operator applies to. */\r\n  target: FilterOperatorTarget\r\n  /* The plural form of the operator, if applicable. */\r\n  singularOf?: FilterOperators[T]\r\n  /* The singular form of the operator, if applicable. */\r\n  pluralOf?: FilterOperators[T]\r\n  /* All related operators. Normally, all the operators which share the same target. */\r\n  relativeOf: FilterOperators[T] | Array<FilterOperators[T]>\r\n  /* Whether the operator is negated. */\r\n  isNegated: boolean\r\n  /* If the operator is not negated, this provides the negated equivalent. */\r\n  negation?: FilterOperators[T]\r\n  /* If the operator is negated, this provides the positive equivalent. */\r\n  negationOf?: FilterOperators[T]\r\n}\r\n\r\n/*\r\n *\r\n * FilterOperatorDetails is a type that provides details about a filter operator for a specific column data type.\r\n * It extends FilterOperatorDetailsBase with additional logic and contraints on the defined properties.\r\n *\r\n */\r\nexport type FilterOperatorDetails<\r\n  OperatorValue,\r\n  T extends ColumnDataType,\r\n> = FilterOperatorDetailsBase<OperatorValue, T> &\r\n  (\r\n    | { singularOf?: never; pluralOf?: never }\r\n    | { target: 'single'; singularOf: FilterOperators[T]; pluralOf?: never }\r\n    | { target: 'multiple'; singularOf?: never; pluralOf: FilterOperators[T] }\r\n  ) &\r\n  (\r\n    | { isNegated: false; negation: FilterOperators[T]; negationOf?: never }\r\n    | { isNegated: true; negation?: never; negationOf: FilterOperators[T] }\r\n  )\r\n\r\n/* Maps column data types to their respective filter operator details */\r\nexport type FilterTypeOperatorDetails = {\r\n  [key in ColumnDataType]: FilterDetails<key>\r\n}\r\n",
=======
      "path": "registry/data-table-filter/core/types.ts",
      "content": "import type { LucideIcon } from 'lucide-react'\n\n/*\n * # GENERAL NOTES:\n *\n * ## GENERICS:\n *\n * TData is the shape of a single row in your data table.\n * TVal is the shape of the underlying value for a column.\n * TType is the type (kind) of the column.\n *\n */\n\nexport type ElementType<T> = T extends (infer U)[] ? U : T\n\nexport type Nullable<T> = T | null | undefined\n\n/*\n * The model of a column option.\n * Used for representing underlying column values of type `option` or `multiOption`.\n */\nexport interface ColumnOption {\n  /* The label to display for the option. */\n  label: string\n  /* The internal value of the option. */\n  value: string\n  /* An optional icon to display next to the label. */\n  icon?: React.ReactElement | React.ElementType\n}\n\n/*\n * Represents the data type (kind) of a column.\n */\nexport type ColumnDataType =\n  /* The column value is a string that should be searchable. */\n  | 'text'\n  | 'number'\n  | 'date'\n  /* The column value can be a single value from a list of options. */\n  | 'option'\n  /* The column value can be zero or more values from a list of options. */\n  | 'multiOption'\n\n/*\n * Represents the data type (kind) of option and multi-option columns.\n */\nexport type OptionBasedColumnDataType = Extract<\n  ColumnDataType,\n  'option' | 'multiOption'\n>\n\n/*\n * Maps a ColumnDataType to it's primitive type (i.e. string, number, etc.).\n */\nexport type ColumnDataNativeMap = {\n  text: string\n  number: number\n  date: Date\n  option: string\n  multiOption: string[]\n}\n\n/*\n * Represents the value of a column filter.\n * Contigent on the filtered column's data type.\n */\nexport type FilterValues<T extends ColumnDataType> = Array<\n  ElementType<ColumnDataNativeMap[T]>\n>\n\n/*\n * An accessor function for a column's data.\n * Uses the original row data as an argument.\n */\nexport type TAccessorFn<TData, TVal = unknown> = (data: TData) => TVal\n\n/*\n * Used by `option` and `multiOption` columns.\n * Transforms the underlying column value into a valid ColumnOption.\n */\nexport type TTransformOptionFn<TVal = unknown> = (\n  value: ElementType<NonNullable<TVal>>,\n) => ColumnOption\n\n/*\n * Used by `option` and `multiOption` columns.\n * A custom ordering function when sorting a column's options.\n */\nexport type TOrderFn<TVal = unknown> = (\n  a: ElementType<NonNullable<TVal>>,\n  b: ElementType<NonNullable<TVal>>,\n) => number\n\n/*\n * The configuration for a column.\n */\nexport type ColumnConfig<\n  TData,\n  TType extends ColumnDataType = any,\n  TVal = unknown,\n  TId extends string = string,\n> = {\n  id: TId\n  accessor: TAccessorFn<TData, TVal>\n  displayName: string\n  icon: LucideIcon\n  type: TType\n  options?: TType extends OptionBasedColumnDataType ? ColumnOption[] : never\n  facetedOptions?: TType extends OptionBasedColumnDataType\n    ? Map<string, number>\n    : never\n  min?: TType extends 'number' ? number : never\n  max?: TType extends 'number' ? number : never\n  transformOptionFn?: TType extends OptionBasedColumnDataType\n    ? TTransformOptionFn<TVal>\n    : never\n  orderFn?: TType extends OptionBasedColumnDataType ? TOrderFn<TVal> : never\n}\n\nexport type OptionColumnId<T> = T extends ColumnConfig<\n  infer TData,\n  'option' | 'multiOption',\n  infer TVal,\n  infer TId\n>\n  ? TId\n  : never\n\nexport type OptionColumnIds<\n  T extends ReadonlyArray<ColumnConfig<any, any, any, any>>,\n> = {\n  [K in keyof T]: OptionColumnId<T[K]>\n}[number]\n\n/*\n * Describes a helper function for creating column configurations.\n */\nexport type ColumnConfigHelper<TData> = {\n  accessor: <\n    TAccessor extends TAccessorFn<TData>,\n    TType extends ColumnDataType,\n    TVal extends ReturnType<TAccessor>,\n  >(\n    accessor: TAccessor,\n    config?: Omit<ColumnConfig<TData, TType, TVal>, 'accessor'>,\n  ) => ColumnConfig<TData, TType, unknown>\n}\n\nexport type DataTableFilterConfig<TData> = {\n  data: TData[]\n  columns: ColumnConfig<TData>[]\n}\n\nexport type ColumnProperties<TData, TVal> = {\n  getOptions: () => ColumnOption[]\n  getValues: () => ElementType<NonNullable<TVal>>[]\n  getFacetedUniqueValues: () => Map<string, number> | undefined\n  getFacetedMinMaxValues: () => number[]\n  prefetchOptions: () => Promise<void> // Prefetch options\n  prefetchValues: () => Promise<void> // Prefetch values\n  prefetchFacetedUniqueValues: () => Promise<void> // Prefetch faceted unique values\n}\n\nexport type ColumnPrivateProperties<TData, TVal> = {\n  _prefetchedOptionsCache: ColumnOption[] | null\n  _prefetchedValuesCache: ElementType<NonNullable<TVal>>[] | null\n  _prefetchedFacetedCache: Map<string, number> | null\n}\n\nexport type Column<\n  TData,\n  TType extends ColumnDataType = any,\n  TVal = unknown,\n> = ColumnConfig<TData, TType, TVal> &\n  ColumnProperties<TData, TVal> &\n  ColumnPrivateProperties<TData, TVal>\n\n/*\n * Describes the available actions on column filters.\n * Includes both column-specific and global actions, ultimately acting on the column filters.\n */\nexport interface DataTableFilterActions {\n  addFilterValue: <TData, TType extends OptionBasedColumnDataType>(\n    column: Column<TData, TType>,\n    values: FilterModel<TType>['values'],\n  ) => void\n\n  removeFilterValue: <TData, TType extends OptionBasedColumnDataType>(\n    column: Column<TData, TType>,\n    value: FilterModel<TType>['values'],\n  ) => void\n\n  setFilterValue: <TData, TType extends ColumnDataType>(\n    column: Column<TData, TType>,\n    values: FilterModel<TType>['values'],\n  ) => void\n\n  setFilterOperator: <TType extends ColumnDataType>(\n    columnId: string,\n    operator: FilterModel<TType>['operator'],\n  ) => void\n\n  removeFilter: (columnId: string) => void\n\n  removeAllFilters: () => void\n}\n\nexport type FilterStrategy = 'client' | 'server'\n\n/* Operators for text data */\nexport type TextFilterOperator = 'contains' | 'does not contain'\n\n/* Operators for number data */\nexport type NumberFilterOperator =\n  | 'is'\n  | 'is not'\n  | 'is less than'\n  | 'is greater than or equal to'\n  | 'is greater than'\n  | 'is less than or equal to'\n  | 'is between'\n  | 'is not between'\n\n/* Operators for date data */\nexport type DateFilterOperator =\n  | 'is'\n  | 'is not'\n  | 'is before'\n  | 'is on or after'\n  | 'is after'\n  | 'is on or before'\n  | 'is between'\n  | 'is not between'\n\n/* Operators for option data */\nexport type OptionFilterOperator = 'is' | 'is not' | 'is any of' | 'is none of'\n\n/* Operators for multi-option data */\nexport type MultiOptionFilterOperator =\n  | 'include'\n  | 'exclude'\n  | 'include any of'\n  | 'include all of'\n  | 'exclude if any of'\n  | 'exclude if all'\n\n/* Maps filter operators to their respective data types */\nexport type FilterOperators = {\n  text: TextFilterOperator\n  number: NumberFilterOperator\n  date: DateFilterOperator\n  option: OptionFilterOperator\n  multiOption: MultiOptionFilterOperator\n}\n\n/*\n *\n * FilterValue is a type that represents a filter value for a specific column.\n *\n * It consists of:\n * - Operator: The operator to be used for the filter.\n * - Values: An array of values to be used for the filter.\n *\n */\nexport type FilterModel<TType extends ColumnDataType = any> = {\n  columnId: string\n  operator: FilterOperators[TType]\n  values: FilterValues<TType>\n}\n\nexport type FiltersState = Array<FilterModel>\n\n/*\n * FilterDetails is a type that represents the details of all the filter operators for a specific column data type.\n */\nexport type FilterDetails<T extends ColumnDataType> = {\n  [key in FilterOperators[T]]: FilterOperatorDetails<key, T>\n}\n\nexport type FilterOperatorTarget = 'single' | 'multiple'\n\nexport type FilterOperatorDetailsBase<\n  OperatorValue,\n  T extends ColumnDataType,\n> = {\n  /* The operator value. Usually the string representation of the operator. */\n  value: OperatorValue\n  /* The label for the operator, to show in the UI. */\n  label: string\n  /* How much data the operator applies to. */\n  target: FilterOperatorTarget\n  /* The plural form of the operator, if applicable. */\n  singularOf?: FilterOperators[T]\n  /* The singular form of the operator, if applicable. */\n  pluralOf?: FilterOperators[T]\n  /* All related operators. Normally, all the operators which share the same target. */\n  relativeOf: FilterOperators[T] | Array<FilterOperators[T]>\n  /* Whether the operator is negated. */\n  isNegated: boolean\n  /* If the operator is not negated, this provides the negated equivalent. */\n  negation?: FilterOperators[T]\n  /* If the operator is negated, this provides the positive equivalent. */\n  negationOf?: FilterOperators[T]\n}\n\n/*\n *\n * FilterOperatorDetails is a type that provides details about a filter operator for a specific column data type.\n * It extends FilterOperatorDetailsBase with additional logic and contraints on the defined properties.\n *\n */\nexport type FilterOperatorDetails<\n  OperatorValue,\n  T extends ColumnDataType,\n> = FilterOperatorDetailsBase<OperatorValue, T> &\n  (\n    | { singularOf?: never; pluralOf?: never }\n    | { target: 'single'; singularOf: FilterOperators[T]; pluralOf?: never }\n    | { target: 'multiple'; singularOf?: never; pluralOf: FilterOperators[T] }\n  ) &\n  (\n    | { isNegated: false; negation: FilterOperators[T]; negationOf?: never }\n    | { isNegated: true; negation?: never; negationOf: FilterOperators[T] }\n  )\n\n/* Maps column data types to their respective filter operator details */\nexport type FilterTypeOperatorDetails = {\n  [key in ColumnDataType]: FilterDetails<key>\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/core/types.ts"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/hooks/use-data-table-filters.tsx",
      "content": "'use client'\r\n\r\nimport { useMemo, useState } from 'react'\r\nimport { createColumns } from '../core/filters'\r\nimport { DEFAULT_OPERATORS, determineNewOperator } from '../core/operators'\r\nimport type {\r\n  ColumnConfig,\r\n  ColumnDataType,\r\n  ColumnOption,\r\n  DataTableFilterActions,\r\n  FilterModel,\r\n  FilterStrategy,\r\n  FiltersState,\r\n  OptionBasedColumnDataType,\r\n  OptionColumnIds,\r\n} from '../core/types'\r\nimport { uniq } from '../lib/array'\r\nimport { addUniq, removeUniq } from '../lib/array'\r\nimport {\r\n  createNumberFilterValue,\r\n  isColumnOptionArray,\r\n  isColumnOptionMap,\r\n} from '../lib/helpers'\r\nimport { Locale } from '../lib/i18n'\r\n\r\nexport interface DataTableFiltersOptions<\r\n  TData,\r\n  TColumns extends ReadonlyArray<ColumnConfig<TData, any, any, any>>,\r\n  TStrategy extends FilterStrategy,\r\n> {\r\n  strategy: TStrategy\r\n  data: TData[]\r\n  columnsConfig: TColumns\r\n  controlledState?:\r\n  | [FiltersState, React.Dispatch<React.SetStateAction<FiltersState>>]\r\n  | undefined\r\n  options?: Partial<\r\n    Record<\r\n      OptionColumnIds<TColumns>,\r\n      | ColumnOption[]\r\n      | [ColumnOption[] | undefined, Map<string, number> | undefined]\r\n    >\r\n  >\r\n  locale?: Locale\r\n}\r\n\r\nexport function useDataTableFilters<\r\n  TData,\r\n  TColumns extends ReadonlyArray<ColumnConfig<TData, any, any, any>>,\r\n  TStrategy extends FilterStrategy,\r\n>({\r\n  strategy,\r\n  data,\r\n  columnsConfig,\r\n  controlledState,\r\n  options,\r\n  locale = 'en',\r\n}: DataTableFiltersOptions<TData, TColumns, TStrategy>) {\r\n  const [internalFilters, setInternalFilters] = useState<FiltersState>([])\r\n  const [filters, setFilters] = controlledState ?? [\r\n    internalFilters,\r\n    setInternalFilters,\r\n  ]\r\n\r\n  // Convert ColumnConfig to Column, applying options and faceted options if provided\r\n  const columns = useMemo(() => {\r\n    const enhancedConfigs = columnsConfig.map((config) => {\r\n      if (\r\n        options &&\r\n        (config.type === 'option' || config.type === 'multiOption')\r\n      ) {\r\n        const optionsInput = options[config.id as OptionColumnIds<TColumns>]\r\n\r\n        if (!optionsInput) return config\r\n\r\n        if (isColumnOptionArray(optionsInput)) {\r\n          return { ...config, options: optionsInput }\r\n        }\r\n\r\n        if (\r\n          isColumnOptionArray(optionsInput[0]) &&\r\n          isColumnOptionMap(optionsInput[1])\r\n        ) {\r\n          return {\r\n            ...config,\r\n            options: optionsInput[0],\r\n            facetedOptions: optionsInput[1],\r\n          }\r\n        }\r\n      }\r\n\r\n      return config\r\n    })\r\n    return createColumns(data, enhancedConfigs, strategy)\r\n  }, [data, columnsConfig, options, strategy])\r\n\r\n  const actions: DataTableFilterActions = useMemo(\r\n    () => ({\r\n      addFilterValue<TData, TType extends OptionBasedColumnDataType>(\r\n        column: ColumnConfig<TData, TType>,\r\n        values: FilterModel<TType>['values'],\r\n      ) {\r\n        if (column.type === 'option') {\r\n          setFilters((prev) => {\r\n            const filter = prev.find((f) => f.columnId === column.id)\r\n            const isColumnFiltered = filter && filter.values.length > 0\r\n            if (!isColumnFiltered) {\r\n              return [\r\n                ...prev,\r\n                {\r\n                  columnId: column.id,\r\n                  operator:\r\n                    values.length > 1\r\n                      ? DEFAULT_OPERATORS[column.type].multiple\r\n                      : DEFAULT_OPERATORS[column.type].single,\r\n                  values,\r\n                },\r\n              ]\r\n            }\r\n            const oldValues = filter.values\r\n            const newValues = addUniq(filter.values, values)\r\n            const newOperator = determineNewOperator(\r\n              'option',\r\n              oldValues,\r\n              newValues,\r\n              filter.operator,\r\n              locale,\r\n            )\r\n            return prev.map((f) =>\r\n              f.columnId === column.id\r\n                ? {\r\n                  columnId: column.id,\r\n                  operator: newOperator,\r\n                  values: newValues,\r\n                }\r\n                : f,\r\n            )\r\n          })\r\n          return\r\n        }\r\n        if (column.type === 'multiOption') {\r\n          setFilters((prev) => {\r\n            const filter = prev.find((f) => f.columnId === column.id)\r\n            const isColumnFiltered = filter && filter.values.length > 0\r\n            if (!isColumnFiltered) {\r\n              return [\r\n                ...prev,\r\n                {\r\n                  columnId: column.id,\r\n                  operator:\r\n                    values.length > 1\r\n                      ? DEFAULT_OPERATORS[column.type].multiple\r\n                      : DEFAULT_OPERATORS[column.type].single,\r\n                  values,\r\n                },\r\n              ]\r\n            }\r\n            const oldValues = filter.values\r\n            const newValues = addUniq(filter.values, values)\r\n            const newOperator = determineNewOperator(\r\n              'multiOption',\r\n              oldValues,\r\n              newValues,\r\n              filter.operator,\r\n              locale,\r\n            )\r\n            if (newValues.length === 0) {\r\n              return prev.filter((f) => f.columnId !== column.id)\r\n            }\r\n            return prev.map((f) =>\r\n              f.columnId === column.id\r\n                ? {\r\n                  columnId: column.id,\r\n                  operator: newOperator,\r\n                  values: newValues,\r\n                }\r\n                : f,\r\n            )\r\n          })\r\n          return\r\n        }\r\n        throw new Error(\r\n          '[data-table-filter] addFilterValue() is only supported for option columns',\r\n        )\r\n      },\r\n      removeFilterValue<TData, TType extends OptionBasedColumnDataType>(\r\n        column: ColumnConfig<TData, TType>,\r\n        value: FilterModel<TType>['values'],\r\n      ) {\r\n        if (column.type === 'option') {\r\n          setFilters((prev) => {\r\n            const filter = prev.find((f) => f.columnId === column.id)\r\n            const isColumnFiltered = filter && filter.values.length > 0\r\n            if (!isColumnFiltered) {\r\n              return [...prev]\r\n            }\r\n            const newValues = removeUniq(filter.values, value)\r\n            const oldValues = filter.values\r\n            const newOperator = determineNewOperator(\r\n              'option',\r\n              oldValues,\r\n              newValues,\r\n              filter.operator,\r\n              locale,\r\n            )\r\n            if (newValues.length === 0) {\r\n              return prev.filter((f) => f.columnId !== column.id)\r\n            }\r\n            return prev.map((f) =>\r\n              f.columnId === column.id\r\n                ? {\r\n                  columnId: column.id,\r\n                  operator: newOperator,\r\n                  values: newValues,\r\n                }\r\n                : f,\r\n            )\r\n          })\r\n          return\r\n        }\r\n        if (column.type === 'multiOption') {\r\n          setFilters((prev) => {\r\n            const filter = prev.find((f) => f.columnId === column.id)\r\n            const isColumnFiltered = filter && filter.values.length > 0\r\n            if (!isColumnFiltered) {\r\n              return [...prev]\r\n            }\r\n            const newValues = removeUniq(filter.values, value)\r\n            const oldValues = filter.values\r\n            const newOperator = determineNewOperator(\r\n              'multiOption',\r\n              oldValues,\r\n              newValues,\r\n              filter.operator,\r\n              locale,\r\n            )\r\n            if (newValues.length === 0) {\r\n              return prev.filter((f) => f.columnId !== column.id)\r\n            }\r\n            return prev.map((f) =>\r\n              f.columnId === column.id\r\n                ? {\r\n                  columnId: column.id,\r\n                  operator: newOperator,\r\n                  values: newValues,\r\n                }\r\n                : f,\r\n            )\r\n          })\r\n          return\r\n        }\r\n        throw new Error(\r\n          '[data-table-filter] removeFilterValue() is only supported for option columns',\r\n        )\r\n      },\r\n      setFilterValue<TData, TType extends ColumnDataType>(\r\n        column: ColumnConfig<TData, TType>,\r\n        values: FilterModel<TType>['values'],\r\n      ) {\r\n        setFilters((prev) => {\r\n          const filter = prev.find((f) => f.columnId === column.id)\r\n          const isColumnFiltered = filter && filter.values.length > 0\r\n          const newValues =\r\n            column.type === 'number'\r\n              ? createNumberFilterValue(values as number[])\r\n              : uniq(values)\r\n          if (newValues.length === 0) return prev\r\n          if (!isColumnFiltered) {\r\n            return [\r\n              ...prev,\r\n              {\r\n                columnId: column.id,\r\n                operator:\r\n                  values.length > 1\r\n                    ? DEFAULT_OPERATORS[column.type].multiple\r\n                    : DEFAULT_OPERATORS[column.type].single,\r\n                values: newValues,\r\n              },\r\n            ]\r\n          }\r\n          const oldValues = filter.values\r\n          const newOperator = determineNewOperator(\r\n            column.type,\r\n            oldValues,\r\n            newValues,\r\n            filter.operator,\r\n            locale,\r\n          )\r\n          const newFilter = {\r\n            columnId: column.id,\r\n            operator: newOperator,\r\n            values: newValues as any,\r\n          } satisfies FilterModel<TType>\r\n          return prev.map((f) => (f.columnId === column.id ? newFilter : f))\r\n        })\r\n      },\r\n      setFilterOperator<TType extends ColumnDataType>(\r\n        columnId: string,\r\n        operator: FilterModel<TType>['operator'],\r\n      ) {\r\n        setFilters((prev) =>\r\n          prev.map((f) => (f.columnId === columnId ? { ...f, operator } : f)),\r\n        )\r\n      },\r\n      removeFilter(columnId: string) {\r\n        setFilters((prev) => prev.filter((f) => f.columnId !== columnId))\r\n      },\r\n      removeAllFilters() {\r\n        setFilters([])\r\n      },\r\n    }),\r\n    [setFilters],\r\n  )\r\n\r\n  return { columns, filters, actions, strategy } // columns is Column<TData>[]\r\n}\r\n",
=======
      "path": "registry/data-table-filter/hooks/use-data-table-filters.tsx",
      "content": "'use client'\n\nimport { useMemo, useState } from 'react'\nimport { createColumns } from '../core/filters'\nimport { DEFAULT_OPERATORS, determineNewOperator } from '../core/operators'\nimport type {\n  ColumnConfig,\n  ColumnDataType,\n  ColumnOption,\n  DataTableFilterActions,\n  FilterModel,\n  FilterStrategy,\n  FiltersState,\n  OptionBasedColumnDataType,\n  OptionColumnIds,\n} from '../core/types'\nimport { uniq } from '../lib/array'\nimport { addUniq, removeUniq } from '../lib/array'\nimport {\n  createNumberFilterValue,\n  isColumnOptionArray,\n  isColumnOptionMap,\n} from '../lib/helpers'\n\nexport interface DataTableFiltersOptions<\n  TData,\n  TColumns extends ReadonlyArray<ColumnConfig<TData, any, any, any>>,\n  TStrategy extends FilterStrategy,\n> {\n  strategy: TStrategy\n  data: TData[]\n  columnsConfig: TColumns\n  controlledState?:\n    | [FiltersState, React.Dispatch<React.SetStateAction<FiltersState>>]\n    | undefined\n  options?: Partial<\n    Record<\n      OptionColumnIds<TColumns>,\n      | ColumnOption[]\n      | [ColumnOption[] | undefined, Map<string, number> | undefined]\n    >\n  >\n}\n\nexport function useDataTableFilters<\n  TData,\n  TColumns extends ReadonlyArray<ColumnConfig<TData, any, any, any>>,\n  TStrategy extends FilterStrategy,\n>({\n  strategy,\n  data,\n  columnsConfig,\n  controlledState,\n  options,\n}: DataTableFiltersOptions<TData, TColumns, TStrategy>) {\n  const [internalFilters, setInternalFilters] = useState<FiltersState>([])\n  const [filters, setFilters] = controlledState ?? [\n    internalFilters,\n    setInternalFilters,\n  ]\n\n  // Convert ColumnConfig to Column, applying options and faceted options if provided\n  const columns = useMemo(() => {\n    const enhancedConfigs = columnsConfig.map((config) => {\n      if (\n        options &&\n        (config.type === 'option' || config.type === 'multiOption')\n      ) {\n        const optionsInput = options[config.id as OptionColumnIds<TColumns>]\n\n        if (!optionsInput) return config\n\n        if (isColumnOptionArray(optionsInput)) {\n          return { ...config, options: optionsInput }\n        }\n\n        if (\n          isColumnOptionArray(optionsInput[0]) &&\n          isColumnOptionMap(optionsInput[1])\n        ) {\n          return {\n            ...config,\n            options: optionsInput[0],\n            facetedOptions: optionsInput[1],\n          }\n        }\n      }\n\n      return config\n    })\n    return createColumns(data, enhancedConfigs, strategy)\n  }, [data, columnsConfig, options, strategy])\n\n  const actions: DataTableFilterActions = useMemo(\n    () => ({\n      addFilterValue<TData, TType extends OptionBasedColumnDataType>(\n        column: ColumnConfig<TData, TType>,\n        values: FilterModel<TType>['values'],\n      ) {\n        if (column.type === 'option') {\n          setFilters((prev) => {\n            const filter = prev.find((f) => f.columnId === column.id)\n            const isColumnFiltered = filter && filter.values.length > 0\n            if (!isColumnFiltered) {\n              return [\n                ...prev,\n                {\n                  columnId: column.id,\n                  operator:\n                    values.length > 1\n                      ? DEFAULT_OPERATORS[column.type].multiple\n                      : DEFAULT_OPERATORS[column.type].single,\n                  values,\n                },\n              ]\n            }\n            const oldValues = filter.values\n            const newValues = addUniq(filter.values, values)\n            const newOperator = determineNewOperator(\n              'option',\n              oldValues,\n              newValues,\n              filter.operator,\n            )\n            return prev.map((f) =>\n              f.columnId === column.id\n                ? {\n                    columnId: column.id,\n                    operator: newOperator,\n                    values: newValues,\n                  }\n                : f,\n            )\n          })\n          return\n        }\n        if (column.type === 'multiOption') {\n          setFilters((prev) => {\n            const filter = prev.find((f) => f.columnId === column.id)\n            const isColumnFiltered = filter && filter.values.length > 0\n            if (!isColumnFiltered) {\n              return [\n                ...prev,\n                {\n                  columnId: column.id,\n                  operator:\n                    values.length > 1\n                      ? DEFAULT_OPERATORS[column.type].multiple\n                      : DEFAULT_OPERATORS[column.type].single,\n                  values,\n                },\n              ]\n            }\n            const oldValues = filter.values\n            const newValues = addUniq(filter.values, values)\n            const newOperator = determineNewOperator(\n              'multiOption',\n              oldValues,\n              newValues,\n              filter.operator,\n            )\n            if (newValues.length === 0) {\n              return prev.filter((f) => f.columnId !== column.id)\n            }\n            return prev.map((f) =>\n              f.columnId === column.id\n                ? {\n                    columnId: column.id,\n                    operator: newOperator,\n                    values: newValues,\n                  }\n                : f,\n            )\n          })\n          return\n        }\n        throw new Error(\n          '[data-table-filter] addFilterValue() is only supported for option columns',\n        )\n      },\n      removeFilterValue<TData, TType extends OptionBasedColumnDataType>(\n        column: ColumnConfig<TData, TType>,\n        value: FilterModel<TType>['values'],\n      ) {\n        if (column.type === 'option') {\n          setFilters((prev) => {\n            const filter = prev.find((f) => f.columnId === column.id)\n            const isColumnFiltered = filter && filter.values.length > 0\n            if (!isColumnFiltered) {\n              return [...prev]\n            }\n            const newValues = removeUniq(filter.values, value)\n            const oldValues = filter.values\n            const newOperator = determineNewOperator(\n              'option',\n              oldValues,\n              newValues,\n              filter.operator,\n            )\n            if (newValues.length === 0) {\n              return prev.filter((f) => f.columnId !== column.id)\n            }\n            return prev.map((f) =>\n              f.columnId === column.id\n                ? {\n                    columnId: column.id,\n                    operator: newOperator,\n                    values: newValues,\n                  }\n                : f,\n            )\n          })\n          return\n        }\n        if (column.type === 'multiOption') {\n          setFilters((prev) => {\n            const filter = prev.find((f) => f.columnId === column.id)\n            const isColumnFiltered = filter && filter.values.length > 0\n            if (!isColumnFiltered) {\n              return [...prev]\n            }\n            const newValues = removeUniq(filter.values, value)\n            const oldValues = filter.values\n            const newOperator = determineNewOperator(\n              'multiOption',\n              oldValues,\n              newValues,\n              filter.operator,\n            )\n            if (newValues.length === 0) {\n              return prev.filter((f) => f.columnId !== column.id)\n            }\n            return prev.map((f) =>\n              f.columnId === column.id\n                ? {\n                    columnId: column.id,\n                    operator: newOperator,\n                    values: newValues,\n                  }\n                : f,\n            )\n          })\n          return\n        }\n        throw new Error(\n          '[data-table-filter] removeFilterValue() is only supported for option columns',\n        )\n      },\n      setFilterValue<TData, TType extends ColumnDataType>(\n        column: ColumnConfig<TData, TType>,\n        values: FilterModel<TType>['values'],\n      ) {\n        setFilters((prev) => {\n          const filter = prev.find((f) => f.columnId === column.id)\n          const isColumnFiltered = filter && filter.values.length > 0\n          const newValues =\n            column.type === 'number'\n              ? createNumberFilterValue(values as number[])\n              : uniq(values)\n          if (newValues.length === 0) return prev\n          if (!isColumnFiltered) {\n            return [\n              ...prev,\n              {\n                columnId: column.id,\n                operator:\n                  values.length > 1\n                    ? DEFAULT_OPERATORS[column.type].multiple\n                    : DEFAULT_OPERATORS[column.type].single,\n                values: newValues,\n              },\n            ]\n          }\n          const oldValues = filter.values\n          const newOperator = determineNewOperator(\n            column.type,\n            oldValues,\n            newValues,\n            filter.operator,\n          )\n          const newFilter = {\n            columnId: column.id,\n            operator: newOperator,\n            values: newValues as any,\n          } satisfies FilterModel<TType>\n          return prev.map((f) => (f.columnId === column.id ? newFilter : f))\n        })\n      },\n      setFilterOperator<TType extends ColumnDataType>(\n        columnId: string,\n        operator: FilterModel<TType>['operator'],\n      ) {\n        setFilters((prev) =>\n          prev.map((f) => (f.columnId === columnId ? { ...f, operator } : f)),\n        )\n      },\n      removeFilter(columnId: string) {\n        setFilters((prev) => prev.filter((f) => f.columnId !== columnId))\n      },\n      removeAllFilters() {\n        setFilters([])\n      },\n    }),\n    [setFilters],\n  )\n\n  return { columns, filters, actions, strategy } // columns is Column<TData>[]\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/hooks/use-data-table-filters.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/integrations/tanstack-table/index.tsx",
      "content": "import type { ColumnDef, ColumnFiltersState } from '@tanstack/react-table'\r\nimport type { Column, FilterModel, FiltersState } from '../../core/types'\r\nimport { multiOptionFilterFn, optionFilterFn } from '../../lib/filter-fns'\r\nimport {\r\n  isColumnOption,\r\n  isColumnOptionArray,\r\n  isStringArray,\r\n} from '../../lib/helpers'\r\nimport { dateFilterFn, numberFilterFn, textFilterFn } from './filter-fns'\r\n\r\ninterface CreateTSTColumns<TData> {\r\n  columns: ColumnDef<TData, any>[]\r\n  configs: Column<TData>[]\r\n}\r\n\r\nexport function createTSTColumns<TData>({\r\n  columns,\r\n  configs,\r\n}: CreateTSTColumns<TData>) {\r\n  const _cols: ColumnDef<TData>[] = []\r\n\r\n  for (const col of columns) {\r\n    // Get the column filter config for this column\r\n    const config = configs.find((c) => c.id === col.id)\r\n\r\n    // If the column is not filterable or doesn't have a filter config, skip it\r\n    if (!col.enableColumnFilter || !config) {\r\n      _cols.push(col)\r\n      continue\r\n    }\r\n\r\n    if (config.type === 'text') {\r\n      col.filterFn = textFilterFn\r\n      _cols.push(col)\r\n      continue\r\n    }\r\n\r\n    if (config.type === 'number') {\r\n      col.filterFn = numberFilterFn\r\n      _cols.push(col)\r\n      continue\r\n    }\r\n\r\n    if (config.type === 'date') {\r\n      col.filterFn = dateFilterFn\r\n      _cols.push(col)\r\n      continue\r\n    }\r\n\r\n    if (config.type === 'option') {\r\n      col.filterFn = (row, columnId, filterValue: FilterModel<'option'>) => {\r\n        const value = row.getValue<unknown>(columnId)\r\n\r\n        if (!value) return false\r\n\r\n        if (typeof value === 'string') {\r\n          return optionFilterFn(value, filterValue)\r\n        }\r\n\r\n        if (isColumnOption(value)) {\r\n          return optionFilterFn(value.value, filterValue)\r\n        }\r\n\r\n        const sanitizedValue = config.transformOptionFn!(value as never)\r\n        return optionFilterFn(sanitizedValue.value, filterValue)\r\n      }\r\n    }\r\n\r\n    if (config.type === 'multiOption') {\r\n      col.filterFn = (\r\n        row,\r\n        columnId,\r\n        filterValue: FilterModel<'multiOption'>,\r\n      ) => {\r\n        const value = row.getValue(columnId)\r\n\r\n        if (!value) return false\r\n\r\n        if (isStringArray(value)) {\r\n          return multiOptionFilterFn(value, filterValue)\r\n        }\r\n\r\n        if (isColumnOptionArray(value)) {\r\n          return multiOptionFilterFn(\r\n            value.map((v) => v.value),\r\n            filterValue,\r\n          )\r\n        }\r\n\r\n        const sanitizedValue = (value as never[]).map((v) =>\r\n          config.transformOptionFn!(v),\r\n        )\r\n\r\n        return multiOptionFilterFn(\r\n          sanitizedValue.map((v) => v.value),\r\n          filterValue,\r\n        )\r\n      }\r\n    }\r\n\r\n    _cols.push(col)\r\n  }\r\n\r\n  return _cols\r\n}\r\n\r\nexport function createTSTFilters(filters: FiltersState): ColumnFiltersState {\r\n  return filters.map((filter) => ({ id: filter.columnId, value: filter }))\r\n}\r\n",
=======
      "path": "registry/data-table-filter/integrations/tanstack-table/index.tsx",
      "content": "import type { ColumnDef, ColumnFiltersState } from '@tanstack/react-table'\nimport type { Column, FilterModel, FiltersState } from '../../core/types'\nimport { multiOptionFilterFn, optionFilterFn } from '../../lib/filter-fns'\nimport {\n  isColumnOption,\n  isColumnOptionArray,\n  isStringArray,\n} from '../../lib/helpers'\nimport { dateFilterFn, numberFilterFn, textFilterFn } from './filter-fns'\n\ninterface CreateTSTColumns<TData> {\n  columns: ColumnDef<TData, any>[]\n  configs: Column<TData>[]\n}\n\nexport function createTSTColumns<TData>({\n  columns,\n  configs,\n}: CreateTSTColumns<TData>) {\n  const _cols: ColumnDef<TData>[] = []\n\n  for (const col of columns) {\n    // Get the column filter config for this column\n    const config = configs.find((c) => c.id === col.id)\n\n    // If the column is not filterable or doesn't have a filter config, skip it\n    if (!col.enableColumnFilter || !config) {\n      _cols.push(col)\n      continue\n    }\n\n    if (config.type === 'text') {\n      col.filterFn = textFilterFn\n      _cols.push(col)\n      continue\n    }\n\n    if (config.type === 'number') {\n      col.filterFn = numberFilterFn\n      _cols.push(col)\n      continue\n    }\n\n    if (config.type === 'date') {\n      col.filterFn = dateFilterFn\n      _cols.push(col)\n      continue\n    }\n\n    if (config.type === 'option') {\n      col.filterFn = (row, columnId, filterValue: FilterModel<'option'>) => {\n        const value = row.getValue<unknown>(columnId)\n\n        if (!value) return false\n\n        if (typeof value === 'string') {\n          return optionFilterFn(value, filterValue)\n        }\n\n        if (isColumnOption(value)) {\n          return optionFilterFn(value.value, filterValue)\n        }\n\n        const sanitizedValue = config.transformOptionFn!(value as never)\n        return optionFilterFn(sanitizedValue.value, filterValue)\n      }\n    }\n\n    if (config.type === 'multiOption') {\n      col.filterFn = (\n        row,\n        columnId,\n        filterValue: FilterModel<'multiOption'>,\n      ) => {\n        const value = row.getValue(columnId)\n\n        if (!value) return false\n\n        if (isStringArray(value)) {\n          return multiOptionFilterFn(value, filterValue)\n        }\n\n        if (isColumnOptionArray(value)) {\n          return multiOptionFilterFn(\n            value.map((v) => v.value),\n            filterValue,\n          )\n        }\n\n        const sanitizedValue = (value as never[]).map((v) =>\n          config.transformOptionFn!(v),\n        )\n\n        return multiOptionFilterFn(\n          sanitizedValue.map((v) => v.value),\n          filterValue,\n        )\n      }\n    }\n\n    _cols.push(col)\n  }\n\n  return _cols\n}\n\nexport function createTSTFilters(filters: FiltersState): ColumnFiltersState {\n  return filters.map((filter) => ({ id: filter.columnId, value: filter }))\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/integrations/tanstack-table/index.tsx"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/integrations/tanstack-table/filter-fns.ts",
      "content": "import type { Row } from '@tanstack/react-table'\r\nimport type { FilterModel } from '../../core/types'\r\nimport * as f from '../../lib/filter-fns'\r\n\r\nexport function dateFilterFn<TData>(\r\n  row: Row<TData>,\r\n  columnId: string,\r\n  filterValue: FilterModel<'date'>,\r\n): boolean {\r\n  const value = row.getValue<Date>(columnId)\r\n\r\n  return f.dateFilterFn(value, filterValue)\r\n}\r\n\r\nexport function textFilterFn<TData>(\r\n  row: Row<TData>,\r\n  columnId: string,\r\n  filterValue: FilterModel<'text'>,\r\n): boolean {\r\n  const value = row.getValue<string>(columnId) ?? ''\r\n\r\n  return f.textFilterFn(value, filterValue)\r\n}\r\n\r\nexport function numberFilterFn<TData>(\r\n  row: Row<TData>,\r\n  columnId: string,\r\n  filterValue: FilterModel<'number'>,\r\n): boolean {\r\n  const value = row.getValue<number>(columnId)\r\n\r\n  return f.numberFilterFn(value, filterValue)\r\n}\r\n",
=======
      "path": "registry/data-table-filter/integrations/tanstack-table/filter-fns.ts",
      "content": "import type { Row } from '@tanstack/react-table'\nimport type { FilterModel } from '../../core/types'\nimport * as f from '../../lib/filter-fns'\n\nexport function dateFilterFn<TData>(\n  row: Row<TData>,\n  columnId: string,\n  filterValue: FilterModel<'date'>,\n): boolean {\n  const value = row.getValue<Date>(columnId)\n\n  return f.dateFilterFn(value, filterValue)\n}\n\nexport function textFilterFn<TData>(\n  row: Row<TData>,\n  columnId: string,\n  filterValue: FilterModel<'text'>,\n): boolean {\n  const value = row.getValue<string>(columnId) ?? ''\n\n  return f.textFilterFn(value, filterValue)\n}\n\nexport function numberFilterFn<TData>(\n  row: Row<TData>,\n  columnId: string,\n  filterValue: FilterModel<'number'>,\n): boolean {\n  const value = row.getValue<number>(columnId)\n\n  return f.numberFilterFn(value, filterValue)\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/integrations/tanstack-table/filter-fns.ts"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/lib/array.ts",
      "content": "export function intersection<T>(a: T[], b: T[]): T[] {\r\n  return a.filter((x) => b.includes(x))\r\n}\r\n\r\n/**\r\n * Computes a stable hash string for any value using deep inspection.\r\n * This function recursively builds a string for primitives, arrays, and objects.\r\n * It uses a cache (WeakMap) to avoid rehashing the same object twice, which is\r\n * particularly beneficial if an object appears in multiple places.\r\n */\r\nfunction deepHash(value: any, cache = new WeakMap<object, string>()): string {\r\n  // Handle primitives and null/undefined.\r\n  if (value === null) return 'null'\r\n  if (value === undefined) return 'undefined'\r\n  const type = typeof value\r\n  if (type === 'number' || type === 'boolean' || type === 'string') {\r\n    return `${type}:${value.toString()}`\r\n  }\r\n  if (type === 'function') {\r\n    // Note: using toString for functions.\r\n    return `function:${value.toString()}`\r\n  }\r\n\r\n  // For objects and arrays, use caching to avoid repeated work.\r\n  if (type === 'object') {\r\n    // If weve seen this object before, return the cached hash.\r\n    if (cache.has(value)) {\r\n      return cache.get(value)!\r\n    }\r\n    let hash: string\r\n    if (Array.isArray(value)) {\r\n      // Compute hash for each element in order.\r\n      hash = `array:[${value.map((v) => deepHash(v, cache)).join(',')}]`\r\n    } else {\r\n      // For objects, sort keys to ensure the representation is stable.\r\n      const keys = Object.keys(value).sort()\r\n      const props = keys\r\n        .map((k) => `${k}:${deepHash(value[k], cache)}`)\r\n        .join(',')\r\n      hash = `object:{${props}}`\r\n    }\r\n    cache.set(value, hash)\r\n    return hash\r\n  }\r\n\r\n  // Fallback if no case matched.\r\n  return `${type}:${value.toString()}`\r\n}\r\n\r\n/**\r\n * Performs deep equality check for any two values.\r\n * This recursively checks primitives, arrays, and plain objects.\r\n */\r\nfunction deepEqual(a: any, b: any): boolean {\r\n  // Check strict equality first.\r\n  if (a === b) return true\r\n  // If types differ, theyre not equal.\r\n  if (typeof a !== typeof b) return false\r\n  if (a === null || b === null || a === undefined || b === undefined)\r\n    return false\r\n\r\n  // Check arrays.\r\n  if (Array.isArray(a)) {\r\n    if (!Array.isArray(b) || a.length !== b.length) return false\r\n    for (let i = 0; i < a.length; i++) {\r\n      if (!deepEqual(a[i], b[i])) return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  // Check objects.\r\n  if (typeof a === 'object') {\r\n    if (typeof b !== 'object') return false\r\n    const aKeys = Object.keys(a).sort()\r\n    const bKeys = Object.keys(b).sort()\r\n    if (aKeys.length !== bKeys.length) return false\r\n    for (let i = 0; i < aKeys.length; i++) {\r\n      if (aKeys[i] !== bKeys[i]) return false\r\n      if (!deepEqual(a[aKeys[i]], b[bKeys[i]])) return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  // For any other types (should be primitives by now), use strict equality.\r\n  return false\r\n}\r\n\r\n/**\r\n * Returns a new array containing only the unique values from the input array.\r\n * Uniqueness is determined by deep equality.\r\n *\r\n * @param arr - The array of values to be filtered.\r\n * @returns A new array with duplicates removed.\r\n */\r\nexport function uniq<T>(arr: T[]): T[] {\r\n  // Use a Map where key is the deep hash and value is an array of items sharing the same hash.\r\n  const seen = new Map<string, T[]>()\r\n  const result: T[] = []\r\n\r\n  for (const item of arr) {\r\n    const hash = deepHash(item)\r\n    if (seen.has(hash)) {\r\n      // There is a potential duplicate; check the stored items with the same hash.\r\n      const itemsWithHash = seen.get(hash)!\r\n      let duplicateFound = false\r\n      for (const existing of itemsWithHash) {\r\n        if (deepEqual(existing, item)) {\r\n          duplicateFound = true\r\n          break\r\n        }\r\n      }\r\n      if (!duplicateFound) {\r\n        itemsWithHash.push(item)\r\n        result.push(item)\r\n      }\r\n    } else {\r\n      // First time this hash appears.\r\n      seen.set(hash, [item])\r\n      result.push(item)\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport function take<T>(a: T[], n: number): T[] {\r\n  return a.slice(0, n)\r\n}\r\n\r\nexport function flatten<T>(a: T[][]): T[] {\r\n  return a.flat()\r\n}\r\n\r\nexport function addUniq<T>(arr: T[], values: T[]): T[] {\r\n  return uniq([...arr, ...values])\r\n}\r\n\r\nexport function removeUniq<T>(arr: T[], values: T[]): T[] {\r\n  return arr.filter((v) => !values.includes(v))\r\n}\r\n\r\nexport function isAnyOf<T>(value: T, values: T[]): boolean {\r\n  return values.includes(value)\r\n}\r\n",
=======
      "path": "registry/data-table-filter/lib/array.ts",
      "content": "export function intersection<T>(a: T[], b: T[]): T[] {\n  return a.filter((x) => b.includes(x))\n}\n\n/**\n * Computes a stable hash string for any value using deep inspection.\n * This function recursively builds a string for primitives, arrays, and objects.\n * It uses a cache (WeakMap) to avoid rehashing the same object twice, which is\n * particularly beneficial if an object appears in multiple places.\n */\nfunction deepHash(value: any, cache = new WeakMap<object, string>()): string {\n  // Handle primitives and null/undefined.\n  if (value === null) return 'null'\n  if (value === undefined) return 'undefined'\n  const type = typeof value\n  if (type === 'number' || type === 'boolean' || type === 'string') {\n    return `${type}:${value.toString()}`\n  }\n  if (type === 'function') {\n    // Note: using toString for functions.\n    return `function:${value.toString()}`\n  }\n\n  // For objects and arrays, use caching to avoid repeated work.\n  if (type === 'object') {\n    // If weve seen this object before, return the cached hash.\n    if (cache.has(value)) {\n      return cache.get(value)!\n    }\n    let hash: string\n    if (Array.isArray(value)) {\n      // Compute hash for each element in order.\n      hash = `array:[${value.map((v) => deepHash(v, cache)).join(',')}]`\n    } else {\n      // For objects, sort keys to ensure the representation is stable.\n      const keys = Object.keys(value).sort()\n      const props = keys\n        .map((k) => `${k}:${deepHash(value[k], cache)}`)\n        .join(',')\n      hash = `object:{${props}}`\n    }\n    cache.set(value, hash)\n    return hash\n  }\n\n  // Fallback if no case matched.\n  return `${type}:${value.toString()}`\n}\n\n/**\n * Performs deep equality check for any two values.\n * This recursively checks primitives, arrays, and plain objects.\n */\nfunction deepEqual(a: any, b: any): boolean {\n  // Check strict equality first.\n  if (a === b) return true\n  // If types differ, theyre not equal.\n  if (typeof a !== typeof b) return false\n  if (a === null || b === null || a === undefined || b === undefined)\n    return false\n\n  // Check arrays.\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) return false\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false\n    }\n    return true\n  }\n\n  // Check objects.\n  if (typeof a === 'object') {\n    if (typeof b !== 'object') return false\n    const aKeys = Object.keys(a).sort()\n    const bKeys = Object.keys(b).sort()\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      if (aKeys[i] !== bKeys[i]) return false\n      if (!deepEqual(a[aKeys[i]], b[bKeys[i]])) return false\n    }\n    return true\n  }\n\n  // For any other types (should be primitives by now), use strict equality.\n  return false\n}\n\n/**\n * Returns a new array containing only the unique values from the input array.\n * Uniqueness is determined by deep equality.\n *\n * @param arr - The array of values to be filtered.\n * @returns A new array with duplicates removed.\n */\nexport function uniq<T>(arr: T[]): T[] {\n  // Use a Map where key is the deep hash and value is an array of items sharing the same hash.\n  const seen = new Map<string, T[]>()\n  const result: T[] = []\n\n  for (const item of arr) {\n    const hash = deepHash(item)\n    if (seen.has(hash)) {\n      // There is a potential duplicate; check the stored items with the same hash.\n      const itemsWithHash = seen.get(hash)!\n      let duplicateFound = false\n      for (const existing of itemsWithHash) {\n        if (deepEqual(existing, item)) {\n          duplicateFound = true\n          break\n        }\n      }\n      if (!duplicateFound) {\n        itemsWithHash.push(item)\n        result.push(item)\n      }\n    } else {\n      // First time this hash appears.\n      seen.set(hash, [item])\n      result.push(item)\n    }\n  }\n\n  return result\n}\n\nexport function take<T>(a: T[], n: number): T[] {\n  return a.slice(0, n)\n}\n\nexport function flatten<T>(a: T[][]): T[] {\n  return a.flat()\n}\n\nexport function addUniq<T>(arr: T[], values: T[]): T[] {\n  return uniq([...arr, ...values])\n}\n\nexport function removeUniq<T>(arr: T[], values: T[]): T[] {\n  return arr.filter((v) => !values.includes(v))\n}\n\nexport function isAnyOf<T>(value: T, values: T[]): boolean {\n  return values.includes(value)\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/lib/array.ts"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/lib/filter-fns.ts",
      "content": "import {\r\n  endOfDay,\r\n  isAfter,\r\n  isBefore,\r\n  isSameDay,\r\n  isWithinInterval,\r\n  startOfDay,\r\n} from 'date-fns'\r\nimport type { FilterModel } from '../core/types'\r\nimport { intersection } from './array'\r\nimport { getDateFilterDetails } from '../core/operators'\r\nimport { Locale } from './i18n'\r\n\r\nexport function optionFilterFn<TData>(\r\n  inputData: string,\r\n  filterValue: FilterModel<'option'>,\r\n) {\r\n  if (!inputData) return false\r\n  if (filterValue.values.length === 0) return true\r\n\r\n  const value = inputData.toString().toLowerCase()\r\n\r\n  const found = !!filterValue.values.find((v) => v.toLowerCase() === value)\r\n\r\n  switch (filterValue.operator) {\r\n    case 'is':\r\n    case 'is any of':\r\n      return found\r\n    case 'is not':\r\n    case 'is none of':\r\n      return !found\r\n  }\r\n}\r\n\r\nexport function multiOptionFilterFn(\r\n  inputData: string[],\r\n  filterValue: FilterModel<'multiOption'>,\r\n) {\r\n  if (!inputData) return false\r\n\r\n  if (\r\n    filterValue.values.length === 0 ||\r\n    !filterValue.values[0] ||\r\n    filterValue.values[0].length === 0\r\n  )\r\n    return true\r\n\r\n  const values = inputData\r\n  const filterValues = filterValue.values\r\n\r\n  switch (filterValue.operator) {\r\n    case 'include':\r\n    case 'include any of':\r\n      return intersection(values, filterValues).length > 0\r\n    case 'exclude':\r\n      return intersection(values, filterValues).length === 0\r\n    case 'exclude if any of':\r\n      return !(intersection(values, filterValues).length > 0)\r\n    case 'include all of':\r\n      return intersection(values, filterValues).length === filterValues.length\r\n    case 'exclude if all':\r\n      return !(\r\n        intersection(values, filterValues).length === filterValues.length\r\n      )\r\n  }\r\n}\r\n\r\nexport function dateFilterFn<TData>(\r\n  inputData: Date,\r\n  filterValue: FilterModel<'date'>,\r\n) {\r\n  if (!filterValue || filterValue.values.length === 0) return true\r\n\r\n  if (\r\n    getDateFilterDetails('en')[filterValue.operator].target === 'single' &&\r\n    filterValue.values.length > 1\r\n  )\r\n    throw new Error('Singular operators require at most one filter value')\r\n\r\n  if (\r\n    filterValue.operator in ['is between', 'is not between'] &&\r\n    filterValue.values.length !== 2\r\n  )\r\n    throw new Error('Plural operators require two filter values')\r\n\r\n  const filterVals = filterValue.values\r\n  const d1 = filterVals[0]\r\n  const d2 = filterVals[1]\r\n\r\n  const value = inputData\r\n\r\n  switch (filterValue.operator) {\r\n    case 'is':\r\n      return isSameDay(value, d1)\r\n    case 'is not':\r\n      return !isSameDay(value, d1)\r\n    case 'is before':\r\n      return isBefore(value, startOfDay(d1))\r\n    case 'is on or after':\r\n      return isSameDay(value, d1) || isAfter(value, startOfDay(d1))\r\n    case 'is after':\r\n      return isAfter(value, startOfDay(d1))\r\n    case 'is on or before':\r\n      return isSameDay(value, d1) || isBefore(value, startOfDay(d1))\r\n    case 'is between':\r\n      return isWithinInterval(value, {\r\n        start: startOfDay(d1),\r\n        end: endOfDay(d2),\r\n      })\r\n    case 'is not between':\r\n      return !isWithinInterval(value, {\r\n        start: startOfDay(filterValue.values[0]),\r\n        end: endOfDay(filterValue.values[1]),\r\n      })\r\n  }\r\n}\r\n\r\nexport function textFilterFn<TData>(\r\n  inputData: string,\r\n  filterValue: FilterModel<'text'>,\r\n) {\r\n  if (!filterValue || filterValue.values.length === 0) return true\r\n\r\n  const value = inputData.toLowerCase().trim()\r\n  const filterStr = filterValue.values[0].toLowerCase().trim()\r\n\r\n  if (filterStr === '') return true\r\n\r\n  const found = value.includes(filterStr)\r\n\r\n  switch (filterValue.operator) {\r\n    case 'contains':\r\n      return found\r\n    case 'does not contain':\r\n      return !found\r\n  }\r\n}\r\n\r\nexport function numberFilterFn<TData>(\r\n  inputData: number,\r\n  filterValue: FilterModel<'number'>,\r\n) {\r\n  if (!filterValue || !filterValue.values || filterValue.values.length === 0) {\r\n    return true\r\n  }\r\n\r\n  const value = inputData\r\n  const filterVal = filterValue.values[0]\r\n\r\n  switch (filterValue.operator) {\r\n    case 'is':\r\n      return value === filterVal\r\n    case 'is not':\r\n      return value !== filterVal\r\n    case 'is greater than':\r\n      return value > filterVal\r\n    case 'is greater than or equal to':\r\n      return value >= filterVal\r\n    case 'is less than':\r\n      return value < filterVal\r\n    case 'is less than or equal to':\r\n      return value <= filterVal\r\n    case 'is between': {\r\n      const lowerBound = filterValue.values[0]\r\n      const upperBound = filterValue.values[1]\r\n      return value >= lowerBound && value <= upperBound\r\n    }\r\n    case 'is not between': {\r\n      const lowerBound = filterValue.values[0]\r\n      const upperBound = filterValue.values[1]\r\n      return value < lowerBound || value > upperBound\r\n    }\r\n    default:\r\n      return true\r\n  }\r\n}\r\n",
=======
      "path": "registry/data-table-filter/lib/filter-fns.ts",
      "content": "import {\n  endOfDay,\n  isAfter,\n  isBefore,\n  isSameDay,\n  isWithinInterval,\n  startOfDay,\n} from 'date-fns'\nimport { dateFilterDetails } from '../core/operators'\nimport type { FilterModel } from '../core/types'\nimport { intersection } from './array'\n\nexport function optionFilterFn<TData>(\n  inputData: string,\n  filterValue: FilterModel<'option'>,\n) {\n  if (!inputData) return false\n  if (filterValue.values.length === 0) return true\n\n  const value = inputData.toString().toLowerCase()\n\n  const found = !!filterValue.values.find((v) => v.toLowerCase() === value)\n\n  switch (filterValue.operator) {\n    case 'is':\n    case 'is any of':\n      return found\n    case 'is not':\n    case 'is none of':\n      return !found\n  }\n}\n\nexport function multiOptionFilterFn(\n  inputData: string[],\n  filterValue: FilterModel<'multiOption'>,\n) {\n  if (!inputData) return false\n\n  if (\n    filterValue.values.length === 0 ||\n    !filterValue.values[0] ||\n    filterValue.values[0].length === 0\n  )\n    return true\n\n  const values = inputData\n  const filterValues = filterValue.values\n\n  switch (filterValue.operator) {\n    case 'include':\n    case 'include any of':\n      return intersection(values, filterValues).length > 0\n    case 'exclude':\n      return intersection(values, filterValues).length === 0\n    case 'exclude if any of':\n      return !(intersection(values, filterValues).length > 0)\n    case 'include all of':\n      return intersection(values, filterValues).length === filterValues.length\n    case 'exclude if all':\n      return !(\n        intersection(values, filterValues).length === filterValues.length\n      )\n  }\n}\n\nexport function dateFilterFn<TData>(\n  inputData: Date,\n  filterValue: FilterModel<'date'>,\n) {\n  if (!filterValue || filterValue.values.length === 0) return true\n\n  if (\n    dateFilterDetails[filterValue.operator].target === 'single' &&\n    filterValue.values.length > 1\n  )\n    throw new Error('Singular operators require at most one filter value')\n\n  if (\n    filterValue.operator in ['is between', 'is not between'] &&\n    filterValue.values.length !== 2\n  )\n    throw new Error('Plural operators require two filter values')\n\n  const filterVals = filterValue.values\n  const d1 = filterVals[0]\n  const d2 = filterVals[1]\n\n  const value = inputData\n\n  switch (filterValue.operator) {\n    case 'is':\n      return isSameDay(value, d1)\n    case 'is not':\n      return !isSameDay(value, d1)\n    case 'is before':\n      return isBefore(value, startOfDay(d1))\n    case 'is on or after':\n      return isSameDay(value, d1) || isAfter(value, startOfDay(d1))\n    case 'is after':\n      return isAfter(value, startOfDay(d1))\n    case 'is on or before':\n      return isSameDay(value, d1) || isBefore(value, startOfDay(d1))\n    case 'is between':\n      return isWithinInterval(value, {\n        start: startOfDay(d1),\n        end: endOfDay(d2),\n      })\n    case 'is not between':\n      return !isWithinInterval(value, {\n        start: startOfDay(filterValue.values[0]),\n        end: endOfDay(filterValue.values[1]),\n      })\n  }\n}\n\nexport function textFilterFn<TData>(\n  inputData: string,\n  filterValue: FilterModel<'text'>,\n) {\n  if (!filterValue || filterValue.values.length === 0) return true\n\n  const value = inputData.toLowerCase().trim()\n  const filterStr = filterValue.values[0].toLowerCase().trim()\n\n  if (filterStr === '') return true\n\n  const found = value.includes(filterStr)\n\n  switch (filterValue.operator) {\n    case 'contains':\n      return found\n    case 'does not contain':\n      return !found\n  }\n}\n\nexport function numberFilterFn<TData>(\n  inputData: number,\n  filterValue: FilterModel<'number'>,\n) {\n  if (!filterValue || !filterValue.values || filterValue.values.length === 0) {\n    return true\n  }\n\n  const value = inputData\n  const filterVal = filterValue.values[0]\n\n  switch (filterValue.operator) {\n    case 'is':\n      return value === filterVal\n    case 'is not':\n      return value !== filterVal\n    case 'is greater than':\n      return value > filterVal\n    case 'is greater than or equal to':\n      return value >= filterVal\n    case 'is less than':\n      return value < filterVal\n    case 'is less than or equal to':\n      return value <= filterVal\n    case 'is between': {\n      const lowerBound = filterValue.values[0]\n      const upperBound = filterValue.values[1]\n      return value >= lowerBound && value <= upperBound\n    }\n    case 'is not between': {\n      const lowerBound = filterValue.values[0]\n      const upperBound = filterValue.values[1]\n      return value < lowerBound || value > upperBound\n    }\n    default:\n      return true\n  }\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/lib/filter-fns.ts"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/lib/memo.ts",
      "content": "export function memo<TDeps extends readonly any[], TResult>(\r\n  getDeps: () => TDeps,\r\n  compute: (deps: TDeps) => TResult,\r\n  options: { key: string },\r\n): () => TResult {\r\n  let prevDeps: TDeps | undefined\r\n  let cachedResult: TResult | undefined\r\n\r\n  return () => {\r\n    // console.log(`[memo] Calling memoized function: ${options.key}`)\r\n\r\n    const deps = getDeps()\r\n\r\n    // If no previous deps or deps have changed, recompute\r\n    if (!prevDeps || !shallowEqual(prevDeps, deps)) {\r\n      // console.log(`[memo] Cache MISS - ${options.key}`)\r\n      cachedResult = compute(deps)\r\n      prevDeps = deps\r\n    } else {\r\n      // console.log(`[memo] Cache HIT - ${options.key}`)\r\n    }\r\n\r\n    return cachedResult!\r\n  }\r\n}\r\n\r\nfunction shallowEqual<T>(arr1: readonly T[], arr2: readonly T[]): boolean {\r\n  if (arr1 === arr2) return true\r\n  if (arr1.length !== arr2.length) return false\r\n\r\n  for (let i = 0; i < arr1.length; i++) {\r\n    if (arr1[i] !== arr2[i]) return false\r\n  }\r\n  return true\r\n}\r\n",
=======
      "path": "registry/data-table-filter/lib/memo.ts",
      "content": "export function memo<TDeps extends readonly any[], TResult>(\n  getDeps: () => TDeps,\n  compute: (deps: TDeps) => TResult,\n  options: { key: string },\n): () => TResult {\n  let prevDeps: TDeps | undefined\n  let cachedResult: TResult | undefined\n\n  return () => {\n    // console.log(`[memo] Calling memoized function: ${options.key}`)\n\n    const deps = getDeps()\n\n    // If no previous deps or deps have changed, recompute\n    if (!prevDeps || !shallowEqual(prevDeps, deps)) {\n      // console.log(`[memo] Cache MISS - ${options.key}`)\n      cachedResult = compute(deps)\n      prevDeps = deps\n    } else {\n      // console.log(`[memo] Cache HIT - ${options.key}`)\n    }\n\n    return cachedResult!\n  }\n}\n\nfunction shallowEqual<T>(arr1: readonly T[], arr2: readonly T[]): boolean {\n  if (arr1 === arr2) return true\n  if (arr1.length !== arr2.length) return false\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) return false\n  }\n  return true\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/lib/memo.ts"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/lib/helpers.ts",
      "content": "import type { Column, ColumnOption } from '../core/types'\r\n\r\nexport function getColumn<TData>(columns: Column<TData>[], id: string) {\r\n  const column = columns.find((c) => c.id === id)\r\n\r\n  if (!column) {\r\n    throw new Error(`Column with id ${id} not found`)\r\n  }\r\n\r\n  return column\r\n}\r\n\r\nexport function createNumberFilterValue(\r\n  values: number[] | undefined,\r\n): number[] {\r\n  if (!values || values.length === 0) return []\r\n  if (values.length === 1) return [values[0]]\r\n  if (values.length === 2) return createNumberRange(values)\r\n  return [values[0], values[1]]\r\n}\r\n\r\nexport function createNumberRange(values: number[] | undefined) {\r\n  let a = 0\r\n  let b = 0\r\n\r\n  if (!values || values.length === 0) return [a, b]\r\n  if (values.length === 1) {\r\n    a = values[0]\r\n  } else {\r\n    a = values[0]\r\n    b = values[1]\r\n  }\r\n\r\n  const [min, max] = a < b ? [a, b] : [b, a]\r\n\r\n  return [min, max]\r\n}\r\n\r\nexport function isColumnOption(value: unknown): value is ColumnOption {\r\n  return (\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    'value' in value &&\r\n    'label' in value\r\n  )\r\n}\r\n\r\nexport function isColumnOptionArray(value: unknown): value is ColumnOption[] {\r\n  return Array.isArray(value) && value.every(isColumnOption)\r\n}\r\n\r\nexport function isStringArray(value: unknown): value is string[] {\r\n  return Array.isArray(value) && value.every((v) => typeof v === 'string')\r\n}\r\n\r\nexport function isColumnOptionMap(\r\n  value: unknown,\r\n): value is Map<string, number> {\r\n  return (\r\n    value instanceof Map &&\r\n    value.keys().every((k) => typeof k === 'string') &&\r\n    value.values().every((v) => typeof v === 'number')\r\n  )\r\n}\r\n",
=======
      "path": "registry/data-table-filter/lib/helpers.ts",
      "content": "import type { Column, ColumnOption } from '../core/types'\n\nexport function getColumn<TData>(columns: Column<TData>[], id: string) {\n  const column = columns.find((c) => c.id === id)\n\n  if (!column) {\n    throw new Error(`Column with id ${id} not found`)\n  }\n\n  return column\n}\n\nexport function createNumberFilterValue(\n  values: number[] | undefined,\n): number[] {\n  if (!values || values.length === 0) return []\n  if (values.length === 1) return [values[0]]\n  if (values.length === 2) return createNumberRange(values)\n  return [values[0], values[1]]\n}\n\nexport function createNumberRange(values: number[] | undefined) {\n  let a = 0\n  let b = 0\n\n  if (!values || values.length === 0) return [a, b]\n  if (values.length === 1) {\n    a = values[0]\n  } else {\n    a = values[0]\n    b = values[1]\n  }\n\n  const [min, max] = a < b ? [a, b] : [b, a]\n\n  return [min, max]\n}\n\nexport function isColumnOption(value: unknown): value is ColumnOption {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'value' in value &&\n    'label' in value\n  )\n}\n\nexport function isColumnOptionArray(value: unknown): value is ColumnOption[] {\n  return Array.isArray(value) && value.every(isColumnOption)\n}\n\nexport function isStringArray(value: unknown): value is string[] {\n  return Array.isArray(value) && value.every((v) => typeof v === 'string')\n}\n\nexport function isColumnOptionMap(\n  value: unknown,\n): value is Map<string, number> {\n  return (\n    value instanceof Map &&\n    value.keys().every((k) => typeof k === 'string') &&\n    value.values().every((v) => typeof v === 'number')\n  )\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/lib/helpers.ts"
    },
    {
<<<<<<< HEAD
      "path": "registry/data-table-filter-v2/ui/debounced-input.tsx",
      "content": "'use client'\r\n\r\nimport { Input } from '@/components/ui/input'\r\nimport { useCallback, useEffect, useState } from 'react'\r\n\r\nfunction debounce<T extends (...args: any[]) => void>(\r\n  func: T,\r\n  wait: number,\r\n): (...args: Parameters<T>) => void {\r\n  let timeout: NodeJS.Timeout\r\n  return (...args: Parameters<T>) => {\r\n    clearTimeout(timeout)\r\n    timeout = setTimeout(() => func(...args), wait)\r\n  }\r\n}\r\n\r\nexport function DebouncedInput({\r\n  value: initialValue,\r\n  onChange,\r\n  debounceMs = 500, // This is the wait time, not the function\r\n  ...props\r\n}: {\r\n  value: string | number\r\n  onChange: (value: string | number) => void\r\n  debounceMs?: number\r\n} & Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange'>) {\r\n  const [value, setValue] = useState(initialValue)\r\n\r\n  // Sync with initialValue when it changes\r\n  useEffect(() => {\r\n    setValue(initialValue)\r\n  }, [initialValue])\r\n\r\n  // Define the debounced function with useCallback\r\n  const debouncedOnChange = useCallback(\r\n    debounce((newValue: string | number) => {\r\n      onChange(newValue)\r\n    }, debounceMs), // Pass the wait time here\r\n    [debounceMs, onChange], // Dependencies\r\n  )\r\n\r\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const newValue = e.target.value\r\n    setValue(newValue) // Update local state immediately\r\n    debouncedOnChange(newValue) // Call debounced version\r\n  }\r\n\r\n  return <Input {...props} value={value} onChange={handleChange} />\r\n}\r\n",
=======
      "path": "registry/data-table-filter/ui/debounced-input.tsx",
      "content": "'use client'\n\nimport { Input } from '@/components/ui/input'\nimport { useCallback, useEffect, useState } from 'react'\n\nfunction debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number,\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => func(...args), wait)\n  }\n}\n\nexport function DebouncedInput({\n  value: initialValue,\n  onChange,\n  debounceMs = 500, // This is the wait time, not the function\n  ...props\n}: {\n  value: string | number\n  onChange: (value: string | number) => void\n  debounceMs?: number\n} & Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange'>) {\n  const [value, setValue] = useState(initialValue)\n\n  // Sync with initialValue when it changes\n  useEffect(() => {\n    setValue(initialValue)\n  }, [initialValue])\n\n  // Define the debounced function with useCallback\n  const debouncedOnChange = useCallback(\n    debounce((newValue: string | number) => {\n      onChange(newValue)\n    }, debounceMs), // Pass the wait time here\n    [debounceMs, onChange], // Dependencies\n  )\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value\n    setValue(newValue) // Update local state immediately\n    debouncedOnChange(newValue) // Call debounced version\n  }\n\n  return <Input {...props} value={value} onChange={handleChange} />\n}\n",
>>>>>>> b95f688065d830851280369b67dda7f1c5e3565e
      "type": "registry:file",
      "target": "components/data-table-filter/ui/debounced-input.tsx"
    }
  ]
}
